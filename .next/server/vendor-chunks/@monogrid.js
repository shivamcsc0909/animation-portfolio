/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@monogrid";
exports.ids = ["vendor-chunks/@monogrid"];
exports.modules = {

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.umd.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/decode.umd.cjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/**\n * @monogrid/gainmap-js v3.4.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */\n\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\")) :\n    0;\n})(this, (function (exports, three) { 'use strict';\n\n    const getBufferForType = (type, width, height) => {\n        let out;\n        switch (type) {\n            case three.UnsignedByteType:\n                out = new Uint8ClampedArray(width * height * 4);\n                break;\n            case three.HalfFloatType:\n                out = new Uint16Array(width * height * 4);\n                break;\n            case three.UnsignedIntType:\n                out = new Uint32Array(width * height * 4);\n                break;\n            case three.ByteType:\n                out = new Int8Array(width * height * 4);\n                break;\n            case three.ShortType:\n                out = new Int16Array(width * height * 4);\n                break;\n            case three.IntType:\n                out = new Int32Array(width * height * 4);\n                break;\n            case three.FloatType:\n                out = new Float32Array(width * height * 4);\n                break;\n            default:\n                throw new Error('Unsupported data type');\n        }\n        return out;\n    };\n    let _canReadPixelsResult;\n    /**\n     * Test if this browser implementation can correctly read pixels from the specified\n     * Render target type.\n     *\n     * Runs only once\n     *\n     * @param type\n     * @param renderer\n     * @param camera\n     * @param renderTargetOptions\n     * @returns\n     */\n    const canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n        if (_canReadPixelsResult !== undefined)\n            return _canReadPixelsResult;\n        const testRT = new three.WebGLRenderTarget(1, 1, renderTargetOptions);\n        renderer.setRenderTarget(testRT);\n        const mesh = new three.Mesh(new three.PlaneGeometry(), new three.MeshBasicMaterial({ color: 0xffffff }));\n        renderer.render(mesh, camera);\n        renderer.setRenderTarget(null);\n        const out = getBufferForType(type, testRT.width, testRT.height);\n        renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n        testRT.dispose();\n        mesh.geometry.dispose();\n        mesh.material.dispose();\n        _canReadPixelsResult = out[0] !== 0;\n        return _canReadPixelsResult;\n    };\n    /**\n     * Utility class used for rendering a texture with a material\n     *\n     * @category Core\n     * @group Core\n     */\n    class QuadRenderer {\n        _renderer;\n        _rendererIsDisposable = false;\n        _material;\n        _scene;\n        _camera;\n        _quad;\n        _renderTarget;\n        _width;\n        _height;\n        _type;\n        _colorSpace;\n        _supportsReadPixels = true;\n        /**\n         * Constructs a new QuadRenderer\n         *\n         * @param options Parameters for this QuadRenderer\n         */\n        constructor(options) {\n            this._width = options.width;\n            this._height = options.height;\n            this._type = options.type;\n            this._colorSpace = options.colorSpace;\n            const rtOptions = {\n                // fixed options\n                format: three.RGBAFormat,\n                depthBuffer: false,\n                stencilBuffer: false,\n                // user options\n                type: this._type, // set in class property\n                colorSpace: this._colorSpace, // set in class property\n                anisotropy: options.renderTargetOptions?.anisotropy !== undefined ? options.renderTargetOptions?.anisotropy : 1,\n                generateMipmaps: options.renderTargetOptions?.generateMipmaps !== undefined ? options.renderTargetOptions?.generateMipmaps : false,\n                magFilter: options.renderTargetOptions?.magFilter !== undefined ? options.renderTargetOptions?.magFilter : three.LinearFilter,\n                minFilter: options.renderTargetOptions?.minFilter !== undefined ? options.renderTargetOptions?.minFilter : three.LinearFilter,\n                samples: options.renderTargetOptions?.samples !== undefined ? options.renderTargetOptions?.samples : undefined,\n                wrapS: options.renderTargetOptions?.wrapS !== undefined ? options.renderTargetOptions?.wrapS : three.ClampToEdgeWrapping,\n                wrapT: options.renderTargetOptions?.wrapT !== undefined ? options.renderTargetOptions?.wrapT : three.ClampToEdgeWrapping\n            };\n            this._material = options.material;\n            if (options.renderer) {\n                this._renderer = options.renderer;\n            }\n            else {\n                this._renderer = QuadRenderer.instantiateRenderer();\n                this._rendererIsDisposable = true;\n            }\n            this._scene = new three.Scene();\n            this._camera = new three.OrthographicCamera();\n            this._camera.position.set(0, 0, 10);\n            this._camera.left = -0.5;\n            this._camera.right = 0.5;\n            this._camera.top = 0.5;\n            this._camera.bottom = -0.5;\n            this._camera.updateProjectionMatrix();\n            if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n                let alternativeType;\n                switch (this._type) {\n                    case three.HalfFloatType:\n                        alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? three.FloatType : undefined;\n                        break;\n                }\n                if (alternativeType !== undefined) {\n                    console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${three.FloatType}`);\n                    this._type = alternativeType;\n                }\n                else {\n                    this._supportsReadPixels = false;\n                    console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n                }\n            }\n            this._quad = new three.Mesh(new three.PlaneGeometry(), this._material);\n            this._quad.geometry.computeBoundingBox();\n            this._scene.add(this._quad);\n            this._renderTarget = new three.WebGLRenderTarget(this.width, this.height, rtOptions);\n            this._renderTarget.texture.mapping = options.renderTargetOptions?.mapping !== undefined ? options.renderTargetOptions?.mapping : three.UVMapping;\n        }\n        /**\n         * Instantiates a temporary renderer\n         *\n         * @returns\n         */\n        static instantiateRenderer() {\n            const renderer = new three.WebGLRenderer();\n            renderer.setSize(128, 128);\n            // renderer.outputColorSpace = SRGBColorSpace\n            // renderer.toneMapping = LinearToneMapping\n            // renderer.debug.checkShaderErrors = false\n            // this._rendererIsDisposable = true\n            return renderer;\n        }\n        /**\n         * Renders the input texture using the specified material\n         */\n        render = () => {\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            }\n            catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        /**\n         * Obtains a Buffer containing the rendered texture.\n         *\n         * @throws Error if the browser cannot read pixels from this RenderTarget type.\n         * @returns a TypedArray containing RGBA values from this renderer\n         */\n        toArray() {\n            if (!this._supportsReadPixels)\n                throw new Error('Can\\'t read pixels in this browser');\n            const out = getBufferForType(this._type, this._width, this._height);\n            this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n            return out;\n        }\n        /**\n         * Performs a readPixel operation in the renderTarget\n         * and returns a DataTexture containing the read data\n         *\n         * @param options options\n         * @returns\n         */\n        toDataTexture(options) {\n            const returnValue = new three.DataTexture(\n            // fixed values\n            this.toArray(), this.width, this.height, three.RGBAFormat, this._type, \n            // user values\n            options?.mapping || three.UVMapping, options?.wrapS || three.ClampToEdgeWrapping, options?.wrapT || three.ClampToEdgeWrapping, options?.magFilter || three.LinearFilter, options?.minFilter || three.LinearFilter, options?.anisotropy || 1, \n            // fixed value\n            three.LinearSRGBColorSpace);\n            // set this afterwards, we can't set it in constructor\n            returnValue.generateMipmaps = options?.generateMipmaps !== undefined ? options?.generateMipmaps : false;\n            return returnValue;\n        }\n        /**\n         * If using a disposable renderer, it will dispose it.\n         */\n        disposeOnDemandRenderer() {\n            this._renderer.setRenderTarget(null);\n            if (this._rendererIsDisposable) {\n                this._renderer.dispose();\n                this._renderer.forceContextLoss();\n            }\n        }\n        /**\n         * Will dispose of **all** assets used by this renderer.\n         *\n         *\n         * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n         * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n         * or are otherwise done with it.\n         *\n         * @example\n         * ```js\n         * const loader = new HDRJPGLoader(renderer)\n         * const result = await loader.loadAsync('gainmap.jpeg')\n         * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n         * // DO NOT dispose the renderTarget here,\n         * // it is used directly in the material\n         * result.dispose()\n         * ```\n         *\n         * @example\n         * ```js\n         * const loader = new HDRJPGLoader(renderer)\n         * const pmremGenerator = new PMREMGenerator( renderer );\n         * const result = await loader.loadAsync('gainmap.jpeg')\n         * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n         * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n         * // renderTarget can be disposed here\n         * // because it was used to generate a PMREM texture\n         * result.dispose(true)\n         * ```\n         */\n        dispose(disposeRenderTarget) {\n            this.disposeOnDemandRenderer();\n            if (disposeRenderTarget) {\n                this.renderTarget.dispose();\n            }\n            // dispose shader material texture uniforms\n            if (this.material instanceof three.ShaderMaterial) {\n                Object.values(this.material.uniforms).forEach(v => {\n                    if (v.value instanceof three.Texture)\n                        v.value.dispose();\n                });\n            }\n            // dispose other material properties\n            Object.values(this.material).forEach(value => {\n                if (value instanceof three.Texture)\n                    value.dispose();\n            });\n            this.material.dispose();\n            this._quad.geometry.dispose();\n        }\n        /**\n         * Width of the texture\n         */\n        get width() { return this._width; }\n        set width(value) {\n            this._width = value;\n            this._renderTarget.setSize(this._width, this._height);\n        }\n        /**\n         * Height of the texture\n         */\n        get height() { return this._height; }\n        set height(value) {\n            this._height = value;\n            this._renderTarget.setSize(this._width, this._height);\n        }\n        /**\n         * The renderer used\n         */\n        get renderer() { return this._renderer; }\n        /**\n         * The `WebGLRenderTarget` used.\n         */\n        get renderTarget() { return this._renderTarget; }\n        set renderTarget(value) {\n            this._renderTarget = value;\n            this._width = value.width;\n            this._height = value.height;\n            // this._type = value.texture.type\n        }\n        /**\n         * The `Material` used.\n         */\n        get material() { return this._material; }\n        /**\n         *\n         */\n        get type() { return this._type; }\n        get colorSpace() { return this._colorSpace; }\n    }\n\n    /**\n     * Shared decode implementation factory\n     * Creates a decode function that prepares a QuadRenderer with the given parameters\n     */\n    function createDecodeFunction(config) {\n        return (params) => {\n            const { sdr, gainMap, renderer } = params;\n            if (sdr.colorSpace !== three.SRGBColorSpace) {\n                console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n                sdr.colorSpace = three.SRGBColorSpace;\n            }\n            sdr.needsUpdate = true;\n            if (gainMap.colorSpace !== three.LinearSRGBColorSpace) {\n                console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n                gainMap.colorSpace = three.LinearSRGBColorSpace;\n            }\n            gainMap.needsUpdate = true;\n            const material = config.createMaterial({\n                ...params,\n                sdr,\n                gainMap\n            });\n            const quadRenderer = config.createQuadRenderer({\n                width: sdr.image.width,\n                height: sdr.image.height,\n                type: three.HalfFloatType,\n                colorSpace: three.LinearSRGBColorSpace,\n                material,\n                renderer,\n                renderTargetOptions: params.renderTargetOptions\n            });\n            return quadRenderer;\n        };\n    }\n\n    class GainMapNotFoundError extends Error {\n    }\n\n    class XMPMetadataNotFoundError extends Error {\n    }\n\n    const getXMLValue = (xml, tag, defaultValue) => {\n        // Check for attribute format first: tag=\"value\"\n        const attributeMatch = new RegExp(`${tag}=\"([^\"]*)\"`, 'i').exec(xml);\n        if (attributeMatch)\n            return attributeMatch[1];\n        // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>\n        const tagMatch = new RegExp(`<${tag}[^>]*>([\\\\s\\\\S]*?)</${tag}>`, 'i').exec(xml);\n        if (tagMatch) {\n            // Check if it contains rdf:li elements\n            const liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\\/rdf:li>/g);\n            if (liValues && liValues.length === 3) {\n                return liValues.map(v => v.replace(/<\\/?rdf:li>/g, ''));\n            }\n            return tagMatch[1].trim();\n        }\n        if (defaultValue !== undefined)\n            return defaultValue;\n        throw new Error(`Can't find ${tag} in gainmap metadata`);\n    };\n    const extractXMP = (input) => {\n        let str;\n        // support node test environment\n        if (typeof TextDecoder !== 'undefined')\n            str = new TextDecoder().decode(input);\n        else\n            str = input.toString();\n        let start = str.indexOf('<x:xmpmeta');\n        while (start !== -1) {\n            const end = str.indexOf('x:xmpmeta>', start);\n            const xmpBlock = str.slice(start, end + 10);\n            try {\n                const gainMapMin = getXMLValue(xmpBlock, 'hdrgm:GainMapMin', '0');\n                const gainMapMax = getXMLValue(xmpBlock, 'hdrgm:GainMapMax');\n                const gamma = getXMLValue(xmpBlock, 'hdrgm:Gamma', '1');\n                const offsetSDR = getXMLValue(xmpBlock, 'hdrgm:OffsetSDR', '0.015625');\n                const offsetHDR = getXMLValue(xmpBlock, 'hdrgm:OffsetHDR', '0.015625');\n                // These are always attributes, so we can use a simpler regex\n                const hdrCapacityMinMatch = /hdrgm:HDRCapacityMin=\"([^\"]*)\"/.exec(xmpBlock);\n                const hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : '0';\n                const hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax=\"([^\"]*)\"/.exec(xmpBlock);\n                if (!hdrCapacityMaxMatch)\n                    throw new Error('Incomplete gainmap metadata');\n                const hdrCapacityMax = hdrCapacityMaxMatch[1];\n                return {\n                    gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n                    gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n                    gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n                    offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n                    offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n                    hdrCapacityMin: parseFloat(hdrCapacityMin),\n                    hdrCapacityMax: parseFloat(hdrCapacityMax)\n                };\n            }\n            catch (e) {\n                // Continue searching for another xmpmeta block if this one fails\n            }\n            start = str.indexOf('<x:xmpmeta', end);\n        }\n    };\n\n    /**\n     * MPF Extractor (Multi Picture Format Extractor)\n     * By Henrik S Nilsson 2019\n     *\n     * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n     * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n     *\n     * Overly commented, and without intention of being complete or production ready.\n     * Created to extract depth maps from iPhone images, and to learn about image metadata.\n     * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n     */\n    class MPFExtractor {\n        options;\n        constructor(options) {\n            this.options = {\n                debug: options && options.debug !== undefined ? options.debug : false,\n                extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n                extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n            };\n        }\n        extract(imageArrayBuffer) {\n            return new Promise((resolve, reject) => {\n                const debug = this.options.debug;\n                const dataView = new DataView(imageArrayBuffer.buffer);\n                // If you're executing this line on a big endian machine, it'll be reversed.\n                // bigEnd further down though, refers to the endianness of the image itself.\n                if (dataView.getUint16(0) !== 0xffd8) {\n                    reject(new Error('Not a valid jpeg'));\n                    return;\n                }\n                const length = dataView.byteLength;\n                let offset = 2;\n                let loops = 0;\n                let marker; // APP# marker\n                while (offset < length) {\n                    if (++loops > 250) {\n                        reject(new Error(`Found no marker after ${loops} loops üòµ`));\n                        return;\n                    }\n                    if (dataView.getUint8(offset) !== 0xff) {\n                        reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                        return;\n                    }\n                    marker = dataView.getUint8(offset + 1);\n                    if (debug)\n                        console.log(`Marker: ${marker.toString(16)}`);\n                    if (marker === 0xe2) {\n                        if (debug)\n                            console.log('Found APP2 marker (0xffe2)');\n                        // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                        // Great way to visualize image information in html is using Exiftool. E.g.:\n                        // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                        const formatPt = offset + 4;\n                        /*\n                         *  Structure of the MP Format Identifier\n                         *\n                         *  Offset Addr.  | Code (Hex)  | Description\n                         *  +00             ff            Marker Prefix      <-- offset\n                         *  +01             e2            APP2\n                         *  +02             #n            APP2 Field Length\n                         *  +03             #n            APP2 Field Length\n                         *  +04             4d            'M'                <-- formatPt\n                         *  +05             50            'P'\n                         *  +06             46            'F'\n                         *  +07             00            NULL\n                         *                                                   <-- tiffOffset\n                         */\n                        if (dataView.getUint32(formatPt) === 0x4d504600) {\n                            // Found MPF tag, so we start dig out sub images\n                            const tiffOffset = formatPt + 4;\n                            let bigEnd; // Endianness from TIFF header\n                            // Test for TIFF validity and endianness\n                            // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                            if (dataView.getUint16(tiffOffset) === 0x4949) {\n                                bigEnd = false;\n                            }\n                            else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                                bigEnd = true;\n                            }\n                            else {\n                                reject(new Error('No valid endianness marker found in TIFF header'));\n                                return;\n                            }\n                            if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                                reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                                return;\n                            }\n                            // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                            // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                            const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                            if (firstIFDOffset < 0x00000008) {\n                                reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                                return;\n                            }\n                            // Move ahead to MP Index IFD\n                            // Assume we're at the first IFD, so firstIFDOffset points to\n                            // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                            // we fail silently here due to this assumption)\n                            // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                            const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                            const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                            // Extract info from MPEntries (starting after Count)\n                            const entriesStart = dirStart + 2;\n                            let numberOfImages = 0;\n                            for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                                // Each entry is 12 Bytes long\n                                // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                                if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                    // stored in Last 4 bytes of its 12 Byte entry.\n                                    numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                                }\n                            }\n                            const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                            const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                            const images = [];\n                            for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n                                const image = {\n                                    MPType: dataView.getUint32(i, !bigEnd),\n                                    size: dataView.getUint32(i + 4, !bigEnd),\n                                    // This offset is specified relative to the address of the MP Endian\n                                    // field in the MP Header, unless the image is a First Individual Image,\n                                    // in which case the value of the offset shall be NULL (0x00000000).\n                                    dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                    dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                    start: -1,\n                                    end: -1,\n                                    isFII: false\n                                };\n                                if (!image.dataOffset) {\n                                    // dataOffset is 0x00000000 for First Individual Image\n                                    image.start = 0;\n                                    image.isFII = true;\n                                }\n                                else {\n                                    image.start = tiffOffset + image.dataOffset;\n                                    image.isFII = false;\n                                }\n                                image.end = image.start + image.size;\n                                images.push(image);\n                            }\n                            if (this.options.extractNonFII && images.length) {\n                                const bufferBlob = new Blob([dataView]);\n                                const imgs = [];\n                                for (const image of images) {\n                                    if (image.isFII && !this.options.extractFII) {\n                                        continue; // Skip FII\n                                    }\n                                    const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                                    // we don't need this\n                                    // const imageUrl = URL.createObjectURL(imageBlob)\n                                    // image.img = document.createElement('img')\n                                    // image.img.src = imageUrl\n                                    imgs.push(imageBlob);\n                                }\n                                resolve(imgs);\n                            }\n                        }\n                    }\n                    offset += 2 + dataView.getUint16(offset + 2);\n                }\n            });\n        }\n    }\n\n    /**\n     * Extracts XMP Metadata and the gain map recovery image\n     * from a single JPEG file.\n     *\n     * @category Decoding Functions\n     * @group Decoding Functions\n     * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n     * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n     * @throws Error if XMP Metadata is not found\n     * @throws Error if Gain map image is not found\n     * @example\n     * import { FileLoader } from 'three'\n     * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n     *\n     * const jpegFile = await new FileLoader()\n     *  .setResponseType('arraybuffer')\n     *  .loadAsync('image.jpg')\n     *\n     * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n     */\n    const extractGainmapFromJPEG = async (jpegFile) => {\n        const metadata = extractXMP(jpegFile);\n        if (!metadata)\n            throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n        const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\n        const images = await mpfExtractor.extract(jpegFile);\n        if (images.length !== 2)\n            throw new GainMapNotFoundError('Gain map recovery image not found');\n        return {\n            sdr: new Uint8Array(await images[0].arrayBuffer()),\n            gainMap: new Uint8Array(await images[1].arrayBuffer()),\n            metadata\n        };\n    };\n\n    /**\n     * private function, async get image from blob\n     *\n     * @param blob\n     * @returns\n     */\n    const getHTMLImageFromBlob = (blob) => {\n        return new Promise((resolve, reject) => {\n            const img = document.createElement('img');\n            img.onload = () => { resolve(img); };\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            img.onerror = (e) => { reject(e); };\n            img.src = URL.createObjectURL(blob);\n        });\n    };\n\n    /**\n     * Shared base class for loaders that extracts common logic\n     */\n    class LoaderBaseShared extends three.Loader {\n        _renderer;\n        _renderTargetOptions;\n        _internalLoadingManager;\n        _config;\n        constructor(config, manager) {\n            super(manager);\n            this._config = config;\n            if (config.renderer)\n                this._renderer = config.renderer;\n            this._internalLoadingManager = new three.LoadingManager();\n        }\n        setRenderer(renderer) {\n            this._renderer = renderer;\n            return this;\n        }\n        setRenderTargetOptions(options) {\n            this._renderTargetOptions = options;\n            return this;\n        }\n        prepareQuadRenderer() {\n            if (!this._renderer) {\n                console.warn('WARNING: A Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n            }\n            const material = this._config.createMaterial({\n                gainMapMax: [1, 1, 1],\n                gainMapMin: [0, 0, 0],\n                gamma: [1, 1, 1],\n                offsetHdr: [1, 1, 1],\n                offsetSdr: [1, 1, 1],\n                hdrCapacityMax: 1,\n                hdrCapacityMin: 0,\n                maxDisplayBoost: 1,\n                gainMap: new three.Texture(),\n                sdr: new three.Texture()\n            });\n            return this._config.createQuadRenderer({\n                width: 16,\n                height: 16,\n                type: three.HalfFloatType,\n                colorSpace: three.LinearSRGBColorSpace,\n                material,\n                renderer: this._renderer,\n                renderTargetOptions: this._renderTargetOptions\n            });\n        }\n        async processImages(sdrBuffer, gainMapBuffer, imageOrientation) {\n            const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\n            const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\n            let sdrImage;\n            let gainMapImage;\n            let needsFlip = false;\n            if (typeof createImageBitmap === 'undefined') {\n                const res = await Promise.all([\n                    gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                    getHTMLImageFromBlob(sdrBlob)\n                ]);\n                gainMapImage = res[0];\n                sdrImage = res[1];\n                needsFlip = imageOrientation === 'flipY';\n            }\n            else {\n                const res = await Promise.all([\n                    gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: imageOrientation || 'flipY' }) : Promise.resolve(undefined),\n                    createImageBitmap(sdrBlob, { imageOrientation: imageOrientation || 'flipY' })\n                ]);\n                gainMapImage = res[0];\n                sdrImage = res[1];\n            }\n            return { sdrImage, gainMapImage, needsFlip };\n        }\n        createTextures(sdrImage, gainMapImage, needsFlip) {\n            const gainMap = new three.Texture(gainMapImage || new ImageData(2, 2), three.UVMapping, three.ClampToEdgeWrapping, three.ClampToEdgeWrapping, three.LinearFilter, three.LinearMipMapLinearFilter, three.RGBAFormat, three.UnsignedByteType, 1, three.LinearSRGBColorSpace);\n            gainMap.flipY = needsFlip;\n            gainMap.needsUpdate = true;\n            const sdr = new three.Texture(sdrImage, three.UVMapping, three.ClampToEdgeWrapping, three.ClampToEdgeWrapping, three.LinearFilter, three.LinearMipMapLinearFilter, three.RGBAFormat, three.UnsignedByteType, 1, three.SRGBColorSpace);\n            sdr.flipY = needsFlip;\n            sdr.needsUpdate = true;\n            return { gainMap, sdr };\n        }\n        updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata) {\n            quadRenderer.width = sdrImage.width;\n            quadRenderer.height = sdrImage.height;\n            quadRenderer.material.gainMap = gainMap;\n            quadRenderer.material.sdr = sdr;\n            quadRenderer.material.gainMapMin = metadata.gainMapMin;\n            quadRenderer.material.gainMapMax = metadata.gainMapMax;\n            quadRenderer.material.offsetHdr = metadata.offsetHdr;\n            quadRenderer.material.offsetSdr = metadata.offsetSdr;\n            quadRenderer.material.gamma = metadata.gamma;\n            quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n            quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n            quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n            quadRenderer.material.needsUpdate = true;\n        }\n    }\n\n    const vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n    const fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n    /**\n     * A Material which is able to decode the Gainmap into a full HDR Representation\n     *\n     * @category Materials\n     * @group Materials\n     */\n    class GainMapDecoderMaterial extends three.ShaderMaterial {\n        _maxDisplayBoost;\n        _hdrCapacityMin;\n        _hdrCapacityMax;\n        /**\n         *\n         * @param params\n         */\n        constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n            super({\n                name: 'GainMapDecoderMaterial',\n                vertexShader,\n                fragmentShader,\n                uniforms: {\n                    sdr: { value: sdr },\n                    gainMap: { value: gainMap },\n                    gamma: { value: new three.Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                    offsetHdr: { value: new three.Vector3().fromArray(offsetHdr) },\n                    offsetSdr: { value: new three.Vector3().fromArray(offsetSdr) },\n                    gainMapMin: { value: new three.Vector3().fromArray(gainMapMin) },\n                    gainMapMax: { value: new three.Vector3().fromArray(gainMapMax) },\n                    weightFactor: {\n                        value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                    }\n                },\n                blending: three.NoBlending,\n                depthTest: false,\n                depthWrite: false\n            });\n            this._maxDisplayBoost = maxDisplayBoost;\n            this._hdrCapacityMin = hdrCapacityMin;\n            this._hdrCapacityMax = hdrCapacityMax;\n            this.needsUpdate = true;\n            this.uniformsNeedUpdate = true;\n        }\n        get sdr() { return this.uniforms.sdr.value; }\n        set sdr(value) { this.uniforms.sdr.value = value; }\n        get gainMap() { return this.uniforms.gainMap.value; }\n        set gainMap(value) { this.uniforms.gainMap.value = value; }\n        /**\n         * @see {@link GainMapMetadata.offsetHdr}\n         */\n        get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n        set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n        /**\n         * @see {@link GainMapMetadata.offsetSdr}\n         */\n        get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n        set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n        /**\n         * @see {@link GainMapMetadata.gainMapMin}\n         */\n        get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n        set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n        /**\n         * @see {@link GainMapMetadata.gainMapMax}\n         */\n        get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n        set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n        /**\n         * @see {@link GainMapMetadata.gamma}\n         */\n        get gamma() {\n            const g = this.uniforms.gamma.value;\n            return [1 / g.x, 1 / g.y, 1 / g.z];\n        }\n        set gamma(value) {\n            const g = this.uniforms.gamma.value;\n            g.x = 1.0 / value[0];\n            g.y = 1.0 / value[1];\n            g.z = 1.0 / value[2];\n        }\n        /**\n         * @see {@link GainMapMetadata.hdrCapacityMin}\n         * @remarks Logarithmic space\n         */\n        get hdrCapacityMin() { return this._hdrCapacityMin; }\n        set hdrCapacityMin(value) {\n            this._hdrCapacityMin = value;\n            this.calculateWeight();\n        }\n        /**\n         * @see {@link GainMapMetadata.hdrCapacityMin}\n         * @remarks Logarithmic space\n         */\n        get hdrCapacityMax() { return this._hdrCapacityMax; }\n        set hdrCapacityMax(value) {\n            this._hdrCapacityMax = value;\n            this.calculateWeight();\n        }\n        /**\n         * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n         * @remarks Non Logarithmic space\n         */\n        get maxDisplayBoost() { return this._maxDisplayBoost; }\n        set maxDisplayBoost(value) {\n            this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n            this.calculateWeight();\n        }\n        calculateWeight() {\n            const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n            this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n        }\n    }\n\n    const decodeImpl = createDecodeFunction({\n        renderer: three.WebGLRenderer,\n        createMaterial: (params) => new GainMapDecoderMaterial(params),\n        createQuadRenderer: (params) => new QuadRenderer(params)\n    });\n    /**\n     * Decodes a gain map using a WebGL RenderTarget\n     *\n     * @category Decoding Functions\n     * @group Decoding Functions\n     * @example\n     * import { decode } from '@monogrid/gainmap-js'\n     * import {\n     *   Mesh,\n     *   MeshBasicMaterial,\n     *   PerspectiveCamera,\n     *   PlaneGeometry,\n     *   Scene,\n     *   TextureLoader,\n     *   WebGLRenderer\n     * } from 'three'\n     *\n     * const renderer = new WebGLRenderer()\n     *\n     * const textureLoader = new TextureLoader()\n     *\n     * // load SDR Representation\n     * const sdr = await textureLoader.loadAsync('sdr.jpg')\n     * // load Gain map recovery image\n     * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n     * // load metadata\n     * const metadata = await (await fetch('metadata.json')).json()\n     *\n     * const result = decode({\n     *   sdr,\n     *   gainMap,\n     *   // this allows to use `result.renderTarget.texture` directly\n     *   renderer,\n     *   // this will restore the full HDR range\n     *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n     *   ...metadata\n     * })\n     *\n     * const scene = new Scene()\n     * // `result` can be used to populate a Texture\n     * const mesh = new Mesh(\n     *   new PlaneGeometry(),\n     *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n     * )\n     * scene.add(mesh)\n     * renderer.render(scene, new PerspectiveCamera())\n     *\n     * // result must be manually disposed\n     * // when you are done using it\n     * result.dispose()\n     *\n     * @param params\n     * @returns\n     * @throws {Error} if the WebGLRenderer fails to render the gain map\n     */\n    const decode = (params) => {\n        // Ensure renderer is defined for the base function\n        if (!params.renderer) {\n            throw new Error('Renderer is required for decode function');\n        }\n        const quadRenderer = decodeImpl({\n            ...params,\n            renderer: params.renderer\n        });\n        try {\n            quadRenderer.render();\n        }\n        catch (e) {\n            quadRenderer.disposeOnDemandRenderer();\n            throw e;\n        }\n        return quadRenderer;\n    };\n\n    /**\n     * Base class for WebGL loaders\n     * @template TUrl - The type of URL used to load resources\n     */\n    class LoaderBaseWebGL extends LoaderBaseShared {\n        constructor(renderer, manager) {\n            super({\n                renderer,\n                createMaterial: (params) => new GainMapDecoderMaterial(params),\n                createQuadRenderer: (params) => new QuadRenderer(params)\n            }, manager);\n        }\n        /**\n         * @private\n         * @param quadRenderer\n         * @param metadata\n         * @param sdrBuffer\n         * @param gainMapBuffer\n         */\n        async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n            const { sdrImage, gainMapImage, needsFlip } = await this.processImages(sdrBuffer, gainMapBuffer, 'flipY');\n            const { gainMap, sdr } = this.createTextures(sdrImage, gainMapImage, needsFlip);\n            this.updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata);\n            quadRenderer.render();\n        }\n    }\n\n    /**\n     * A Three.js Loader for the gain map format.\n     *\n     * @category Loaders\n     * @group Loaders\n     *\n     * @example\n     * import { GainMapLoader } from '@monogrid/gainmap-js'\n     * import {\n     *   EquirectangularReflectionMapping,\n     *   Mesh,\n     *   MeshBasicMaterial,\n     *   PerspectiveCamera,\n     *   PlaneGeometry,\n     *   Scene,\n     *   WebGLRenderer\n     * } from 'three'\n     *\n     * const renderer = new WebGLRenderer()\n     *\n     * const loader = new GainMapLoader(renderer)\n     *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n     *\n     * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n     * // `result` can be used to populate a Texture\n     *\n     * const scene = new Scene()\n     * const mesh = new Mesh(\n     *   new PlaneGeometry(),\n     *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n     * )\n     * scene.add(mesh)\n     * renderer.render(scene, new PerspectiveCamera())\n     *\n     * // Starting from three.js r159\n     * // `result.renderTarget.texture` can\n     * // also be used as Equirectangular scene background\n     * //\n     * // it was previously needed to convert it\n     * // to a DataTexture with `result.toDataTexture()`\n     * scene.background = result.renderTarget.texture\n     *\n     * // result must be manually disposed\n     * // when you are done using it\n     * result.dispose()\n     *\n     */\n    class GainMapLoader extends LoaderBaseWebGL {\n        /**\n         * Loads a gainmap using separate data\n         * * sdr image\n         * * gain map image\n         * * metadata json\n         *\n         * useful for webp gain maps\n         *\n         * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n         * @param onLoad Load complete callback, will receive the result\n         * @param onProgress Progress callback, will receive a `ProgressEvent`\n         * @param onError Error callback\n         * @returns\n         */\n        load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n            const quadRenderer = this.prepareQuadRenderer();\n            let sdr;\n            let gainMap;\n            let metadata;\n            const loadCheck = async () => {\n                if (sdr && gainMap && metadata) {\n                    // solves #16\n                    try {\n                        await this.render(quadRenderer, metadata, sdr, gainMap);\n                    }\n                    catch (error) {\n                        this.manager.itemError(sdrUrl);\n                        this.manager.itemError(gainMapUrl);\n                        this.manager.itemError(metadataUrl);\n                        if (typeof onError === 'function')\n                            onError(error);\n                        quadRenderer.disposeOnDemandRenderer();\n                        return;\n                    }\n                    if (typeof onLoad === 'function')\n                        onLoad(quadRenderer);\n                    this.manager.itemEnd(sdrUrl);\n                    this.manager.itemEnd(gainMapUrl);\n                    this.manager.itemEnd(metadataUrl);\n                    quadRenderer.disposeOnDemandRenderer();\n                }\n            };\n            let sdrLengthComputable = true;\n            let sdrTotal = 0;\n            let sdrLoaded = 0;\n            let gainMapLengthComputable = true;\n            let gainMapTotal = 0;\n            let gainMapLoaded = 0;\n            let metadataLengthComputable = true;\n            let metadataTotal = 0;\n            let metadataLoaded = 0;\n            const progressHandler = () => {\n                if (typeof onProgress === 'function') {\n                    const total = sdrTotal + gainMapTotal + metadataTotal;\n                    const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                    const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                    onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n                }\n            };\n            this.manager.itemStart(sdrUrl);\n            this.manager.itemStart(gainMapUrl);\n            this.manager.itemStart(metadataUrl);\n            const sdrLoader = new three.FileLoader(this._internalLoadingManager);\n            sdrLoader.setResponseType('arraybuffer');\n            sdrLoader.setRequestHeader(this.requestHeader);\n            sdrLoader.setPath(this.path);\n            sdrLoader.setWithCredentials(this.withCredentials);\n            sdrLoader.load(sdrUrl, async (buffer) => {\n                /* istanbul ignore if\n                 this condition exists only because of three.js types + strict mode\n                */\n                if (typeof buffer === 'string')\n                    throw new Error('Invalid sdr buffer');\n                sdr = buffer;\n                await loadCheck();\n            }, (e) => {\n                sdrLengthComputable = e.lengthComputable;\n                sdrLoaded = e.loaded;\n                sdrTotal = e.total;\n                progressHandler();\n            }, (error) => {\n                this.manager.itemError(sdrUrl);\n                if (typeof onError === 'function')\n                    onError(error);\n            });\n            const gainMapLoader = new three.FileLoader(this._internalLoadingManager);\n            gainMapLoader.setResponseType('arraybuffer');\n            gainMapLoader.setRequestHeader(this.requestHeader);\n            gainMapLoader.setPath(this.path);\n            gainMapLoader.setWithCredentials(this.withCredentials);\n            gainMapLoader.load(gainMapUrl, async (buffer) => {\n                /* istanbul ignore if\n                 this condition exists only because of three.js types + strict mode\n                */\n                if (typeof buffer === 'string')\n                    throw new Error('Invalid gainmap buffer');\n                gainMap = buffer;\n                await loadCheck();\n            }, (e) => {\n                gainMapLengthComputable = e.lengthComputable;\n                gainMapLoaded = e.loaded;\n                gainMapTotal = e.total;\n                progressHandler();\n            }, (error) => {\n                this.manager.itemError(gainMapUrl);\n                if (typeof onError === 'function')\n                    onError(error);\n            });\n            const metadataLoader = new three.FileLoader(this._internalLoadingManager);\n            // metadataLoader.setResponseType('json')\n            metadataLoader.setRequestHeader(this.requestHeader);\n            metadataLoader.setPath(this.path);\n            metadataLoader.setWithCredentials(this.withCredentials);\n            metadataLoader.load(metadataUrl, async (json) => {\n                /* istanbul ignore if\n                 this condition exists only because of three.js types + strict mode\n                */\n                if (typeof json !== 'string')\n                    throw new Error('Invalid metadata string');\n                // TODO: implement check on JSON file and remove this eslint disable\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                metadata = JSON.parse(json);\n                await loadCheck();\n            }, (e) => {\n                metadataLengthComputable = e.lengthComputable;\n                metadataLoaded = e.loaded;\n                metadataTotal = e.total;\n                progressHandler();\n            }, (error) => {\n                this.manager.itemError(metadataUrl);\n                if (typeof onError === 'function')\n                    onError(error);\n            });\n            return quadRenderer;\n        }\n    }\n\n    /**\n     * A Three.js Loader for a JPEG with embedded gainmap metadata.\n     *\n     * @category Loaders\n     * @group Loaders\n     *\n     * @example\n     * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n     * import {\n     *   EquirectangularReflectionMapping,\n     *   Mesh,\n     *   MeshBasicMaterial,\n     *   PerspectiveCamera,\n     *   PlaneGeometry,\n     *   Scene,\n     *   WebGLRenderer\n     * } from 'three'\n     *\n     * const renderer = new WebGLRenderer()\n     *\n     * const loader = new HDRJPGLoader(renderer)\n     *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n     *\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * // `result` can be used to populate a Texture\n     *\n     * const scene = new Scene()\n     * const mesh = new Mesh(\n     *   new PlaneGeometry(),\n     *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n     * )\n     * scene.add(mesh)\n     * renderer.render(scene, new PerspectiveCamera())\n     *\n     * // Starting from three.js r159\n     * // `result.renderTarget.texture` can\n     * // also be used as Equirectangular scene background\n     * //\n     * // it was previously needed to convert it\n     * // to a DataTexture with `result.toDataTexture()`\n     * scene.background = result.renderTarget.texture\n     *\n     * // result must be manually disposed\n     * // when you are done using it\n     * result.dispose()\n     *\n     */\n    class HDRJPGLoader extends LoaderBaseWebGL {\n        /**\n         * Loads a JPEG containing gain map metadata\n         * Renders a normal SDR image if gainmap data is not found\n         *\n         * @param url Path to a JPEG file containing embedded gain map metadata\n         * @param onLoad Load complete callback, will receive the result\n         * @param onProgress Progress callback, will receive a `ProgressEvent`\n         * @param onError Error callback\n         * @returns\n         */\n        load(url, onLoad, onProgress, onError) {\n            const quadRenderer = this.prepareQuadRenderer();\n            const loader = new three.FileLoader(this._internalLoadingManager);\n            loader.setResponseType('arraybuffer');\n            loader.setRequestHeader(this.requestHeader);\n            loader.setPath(this.path);\n            loader.setWithCredentials(this.withCredentials);\n            this.manager.itemStart(url);\n            loader.load(url, async (jpeg) => {\n                /* istanbul ignore if\n                 this condition exists only because of three.js types + strict mode\n                */\n                if (typeof jpeg === 'string')\n                    throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n                const jpegBuffer = new Uint8Array(jpeg);\n                let sdrJPEG;\n                let gainMapJPEG;\n                let metadata;\n                try {\n                    const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                    // gain map is successfully reconstructed\n                    sdrJPEG = extractionResult.sdr;\n                    gainMapJPEG = extractionResult.gainMap;\n                    metadata = extractionResult.metadata;\n                }\n                catch (e) {\n                    // render the SDR version if this is not a gainmap\n                    if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                        console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                        metadata = {\n                            gainMapMin: [0, 0, 0],\n                            gainMapMax: [1, 1, 1],\n                            gamma: [1, 1, 1],\n                            hdrCapacityMin: 0,\n                            hdrCapacityMax: 1,\n                            offsetHdr: [0, 0, 0],\n                            offsetSdr: [0, 0, 0]\n                        };\n                        sdrJPEG = jpegBuffer;\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdrJPEG.buffer, gainMapJPEG?.buffer);\n                }\n                catch (error) {\n                    this.manager.itemError(url);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(url);\n                quadRenderer.disposeOnDemandRenderer();\n            }, onProgress, (error) => {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n            });\n            return quadRenderer;\n        }\n    }\n\n    exports.GainMapDecoderMaterial = GainMapDecoderMaterial;\n    exports.GainMapLoader = GainMapLoader;\n    exports.GainMapNotFoundError = GainMapNotFoundError;\n    exports.HDRJPGLoader = HDRJPGLoader;\n    exports.JPEGRLoader = HDRJPGLoader;\n    exports.LoaderBaseShared = LoaderBaseShared;\n    exports.MPFExtractor = MPFExtractor;\n    exports.QuadRenderer = QuadRenderer;\n    exports.XMPMetadataNotFoundError = XMPMetadataNotFoundError;\n    exports.createDecodeFunction = createDecodeFunction;\n    exports.decode = decode;\n    exports.extractGainmapFromJPEG = extractGainmapFromJPEG;\n    exports.extractXMP = extractXMP;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9kZWNvZGUudW1kLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMseURBQU87QUFDbkcsSUFBSSxDQUNzSTtBQUMxSSxDQUFDLHFDQUFxQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixpQkFBaUI7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsWUFBWSw4QkFBOEIsZ0JBQWdCO0FBQ2hKO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AbW9ub2dyaWQvZ2Fpbm1hcC1qcy9kaXN0L2RlY29kZS51bWQuY2pzPzg1NWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9ub2dyaWQvZ2Fpbm1hcC1qcyB2My40LjBcbiAqIFdpdGgg4p2k77iPLCBieSBNT05PR1JJRCA8Z2Fpbm1hcEBtb25vZ3JpZC5jb20+XG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3RocmVlJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3RocmVlJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbFtcIkBtb25vZ3JpZC9nYWlubWFwLWpzXCJdID0ge30sIGdsb2JhbC50aHJlZSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCB0aHJlZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBnZXRCdWZmZXJGb3JUeXBlID0gKHR5cGUsIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgICAgbGV0IG91dDtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIHRocmVlLlVuc2lnbmVkQnl0ZVR5cGU6XG4gICAgICAgICAgICAgICAgb3V0ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRocmVlLkhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICAgICAgb3V0ID0gbmV3IFVpbnQxNkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRocmVlLlVuc2lnbmVkSW50VHlwZTpcbiAgICAgICAgICAgICAgICBvdXQgPSBuZXcgVWludDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhyZWUuQnl0ZVR5cGU6XG4gICAgICAgICAgICAgICAgb3V0ID0gbmV3IEludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aHJlZS5TaG9ydFR5cGU6XG4gICAgICAgICAgICAgICAgb3V0ID0gbmV3IEludDE2QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhyZWUuSW50VHlwZTpcbiAgICAgICAgICAgICAgICBvdXQgPSBuZXcgSW50MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aHJlZS5GbG9hdFR5cGU6XG4gICAgICAgICAgICAgICAgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBsZXQgX2NhblJlYWRQaXhlbHNSZXN1bHQ7XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGlzIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gY2FuIGNvcnJlY3RseSByZWFkIHBpeGVscyBmcm9tIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBSZW5kZXIgdGFyZ2V0IHR5cGUuXG4gICAgICpcbiAgICAgKiBSdW5zIG9ubHkgb25jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVcbiAgICAgKiBAcGFyYW0gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gY2FtZXJhXG4gICAgICogQHBhcmFtIHJlbmRlclRhcmdldE9wdGlvbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNvbnN0IGNhblJlYWRQaXhlbHMgPSAodHlwZSwgcmVuZGVyZXIsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0T3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoX2NhblJlYWRQaXhlbHNSZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBfY2FuUmVhZFBpeGVsc1Jlc3VsdDtcbiAgICAgICAgY29uc3QgdGVzdFJUID0gbmV3IHRocmVlLldlYkdMUmVuZGVyVGFyZ2V0KDEsIDEsIHJlbmRlclRhcmdldE9wdGlvbnMpO1xuICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGVzdFJUKTtcbiAgICAgICAgY29uc3QgbWVzaCA9IG5ldyB0aHJlZS5NZXNoKG5ldyB0aHJlZS5QbGFuZUdlb21ldHJ5KCksIG5ldyB0aHJlZS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZmZmZiB9KSk7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcihtZXNoLCBjYW1lcmEpO1xuICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICAgIGNvbnN0IG91dCA9IGdldEJ1ZmZlckZvclR5cGUodHlwZSwgdGVzdFJULndpZHRoLCB0ZXN0UlQuaGVpZ2h0KTtcbiAgICAgICAgcmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVscyh0ZXN0UlQsIDAsIDAsIHRlc3RSVC53aWR0aCwgdGVzdFJULmhlaWdodCwgb3V0KTtcbiAgICAgICAgdGVzdFJULmRpc3Bvc2UoKTtcbiAgICAgICAgbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIG1lc2gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICBfY2FuUmVhZFBpeGVsc1Jlc3VsdCA9IG91dFswXSAhPT0gMDtcbiAgICAgICAgcmV0dXJuIF9jYW5SZWFkUGl4ZWxzUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXRpbGl0eSBjbGFzcyB1c2VkIGZvciByZW5kZXJpbmcgYSB0ZXh0dXJlIHdpdGggYSBtYXRlcmlhbFxuICAgICAqXG4gICAgICogQGNhdGVnb3J5IENvcmVcbiAgICAgKiBAZ3JvdXAgQ29yZVxuICAgICAqL1xuICAgIGNsYXNzIFF1YWRSZW5kZXJlciB7XG4gICAgICAgIF9yZW5kZXJlcjtcbiAgICAgICAgX3JlbmRlcmVySXNEaXNwb3NhYmxlID0gZmFsc2U7XG4gICAgICAgIF9tYXRlcmlhbDtcbiAgICAgICAgX3NjZW5lO1xuICAgICAgICBfY2FtZXJhO1xuICAgICAgICBfcXVhZDtcbiAgICAgICAgX3JlbmRlclRhcmdldDtcbiAgICAgICAgX3dpZHRoO1xuICAgICAgICBfaGVpZ2h0O1xuICAgICAgICBfdHlwZTtcbiAgICAgICAgX2NvbG9yU3BhY2U7XG4gICAgICAgIF9zdXBwb3J0c1JlYWRQaXhlbHMgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBRdWFkUmVuZGVyZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgUGFyYW1ldGVycyBmb3IgdGhpcyBRdWFkUmVuZGVyZXJcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yU3BhY2UgPSBvcHRpb25zLmNvbG9yU3BhY2U7XG4gICAgICAgICAgICBjb25zdCBydE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLy8gZml4ZWQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIGZvcm1hdDogdGhyZWUuUkdCQUZvcm1hdCxcbiAgICAgICAgICAgICAgICBkZXB0aEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3RlbmNpbEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgLy8gdXNlciBvcHRpb25zXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5fdHlwZSwgLy8gc2V0IGluIGNsYXNzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgY29sb3JTcGFjZTogdGhpcy5fY29sb3JTcGFjZSwgLy8gc2V0IGluIGNsYXNzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgYW5pc290cm9weTogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/LmFuaXNvdHJvcHkgOiAxLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlTWlwbWFwczogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8uZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWFnRmlsdGVyOiBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/Lm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5tYWdGaWx0ZXIgOiB0aHJlZS5MaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICAgICAgbWluRmlsdGVyOiBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/Lm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5taW5GaWx0ZXIgOiB0aHJlZS5MaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICAgICAgc2FtcGxlczogb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5zYW1wbGVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/LnNhbXBsZXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgd3JhcFM6IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ud3JhcFMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ud3JhcFMgOiB0aHJlZS5DbGFtcFRvRWRnZVdyYXBwaW5nLFxuICAgICAgICAgICAgICAgIHdyYXBUOiBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/LndyYXBUICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/LndyYXBUIDogdGhyZWUuQ2xhbXBUb0VkZ2VXcmFwcGluZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX21hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBvcHRpb25zLnJlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBRdWFkUmVuZGVyZXIuaW5zdGFudGlhdGVSZW5kZXJlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVySXNEaXNwb3NhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NjZW5lID0gbmV3IHRocmVlLlNjZW5lKCk7XG4gICAgICAgICAgICB0aGlzLl9jYW1lcmEgPSBuZXcgdGhyZWUuT3J0aG9ncmFwaGljQ2FtZXJhKCk7XG4gICAgICAgICAgICB0aGlzLl9jYW1lcmEucG9zaXRpb24uc2V0KDAsIDAsIDEwKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYS5sZWZ0ID0gLTAuNTtcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYS5yaWdodCA9IDAuNTtcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYS50b3AgPSAwLjU7XG4gICAgICAgICAgICB0aGlzLl9jYW1lcmEuYm90dG9tID0gLTAuNTtcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgICAgICBpZiAoIWNhblJlYWRQaXhlbHModGhpcy5fdHlwZSwgdGhpcy5fcmVuZGVyZXIsIHRoaXMuX2NhbWVyYSwgcnRPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIGxldCBhbHRlcm5hdGl2ZVR5cGU7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhyZWUuSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlVHlwZSA9IHRoaXMuX3JlbmRlcmVyLmV4dGVuc2lvbnMuaGFzKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JykgPyB0aHJlZS5GbG9hdFR5cGUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFsdGVybmF0aXZlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgcmVhZGluZyBwaXhlbHMgZnJvbSAke3RoaXMuX3R5cGV9IFJlbmRlclRhcmdldHMsIHN3aXRjaGluZyB0byAke3RocmVlLkZsb2F0VHlwZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHlwZSA9IGFsdGVybmF0aXZlVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1cHBvcnRzUmVhZFBpeGVscyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoaXMgYnJvd3NlciBkb3Mgbm90IHN1cHBvcnQgdG9BcnJheSBvciB0b0RhdGFUZXh0dXJlLCBjYWxscyB0byB0aG9zZSBtZXRob2RzIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIHRocm93bicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3F1YWQgPSBuZXcgdGhyZWUuTWVzaChuZXcgdGhyZWUuUGxhbmVHZW9tZXRyeSgpLCB0aGlzLl9tYXRlcmlhbCk7XG4gICAgICAgICAgICB0aGlzLl9xdWFkLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgdGhpcy5fc2NlbmUuYWRkKHRoaXMuX3F1YWQpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gbmV3IHRocmVlLldlYkdMUmVuZGVyVGFyZ2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBydE9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0LnRleHR1cmUubWFwcGluZyA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ubWFwcGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5tYXBwaW5nIDogdGhyZWUuVVZNYXBwaW5nO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSB0ZW1wb3JhcnkgcmVuZGVyZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBpbnN0YW50aWF0ZVJlbmRlcmVyKCkge1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgdGhyZWUuV2ViR0xSZW5kZXJlcigpO1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSgxMjgsIDEyOCk7XG4gICAgICAgICAgICAvLyByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2VcbiAgICAgICAgICAgIC8vIHJlbmRlcmVyLnRvbmVNYXBwaW5nID0gTGluZWFyVG9uZU1hcHBpbmdcbiAgICAgICAgICAgIC8vIHJlbmRlcmVyLmRlYnVnLmNoZWNrU2hhZGVyRXJyb3JzID0gZmFsc2VcbiAgICAgICAgICAgIC8vIHRoaXMuX3JlbmRlcmVySXNEaXNwb3NhYmxlID0gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIHRoZSBpbnB1dCB0ZXh0dXJlIHVzaW5nIHRoZSBzcGVjaWZpZWQgbWF0ZXJpYWxcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLl9yZW5kZXJUYXJnZXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXIodGhpcy5fc2NlbmUsIHRoaXMuX2NhbWVyYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT2J0YWlucyBhIEJ1ZmZlciBjb250YWluaW5nIHRoZSByZW5kZXJlZCB0ZXh0dXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBicm93c2VyIGNhbm5vdCByZWFkIHBpeGVscyBmcm9tIHRoaXMgUmVuZGVyVGFyZ2V0IHR5cGUuXG4gICAgICAgICAqIEByZXR1cm5zIGEgVHlwZWRBcnJheSBjb250YWluaW5nIFJHQkEgdmFsdWVzIGZyb20gdGhpcyByZW5kZXJlclxuICAgICAgICAgKi9cbiAgICAgICAgdG9BcnJheSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3VwcG9ydHNSZWFkUGl4ZWxzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCByZWFkIHBpeGVscyBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IGdldEJ1ZmZlckZvclR5cGUodGhpcy5fdHlwZSwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzKHRoaXMuX3JlbmRlclRhcmdldCwgMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgb3V0KTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgcmVhZFBpeGVsIG9wZXJhdGlvbiBpbiB0aGUgcmVuZGVyVGFyZ2V0XG4gICAgICAgICAqIGFuZCByZXR1cm5zIGEgRGF0YVRleHR1cmUgY29udGFpbmluZyB0aGUgcmVhZCBkYXRhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIHRvRGF0YVRleHR1cmUob3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBuZXcgdGhyZWUuRGF0YVRleHR1cmUoXG4gICAgICAgICAgICAvLyBmaXhlZCB2YWx1ZXNcbiAgICAgICAgICAgIHRoaXMudG9BcnJheSgpLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhyZWUuUkdCQUZvcm1hdCwgdGhpcy5fdHlwZSwgXG4gICAgICAgICAgICAvLyB1c2VyIHZhbHVlc1xuICAgICAgICAgICAgb3B0aW9ucz8ubWFwcGluZyB8fCB0aHJlZS5VVk1hcHBpbmcsIG9wdGlvbnM/LndyYXBTIHx8IHRocmVlLkNsYW1wVG9FZGdlV3JhcHBpbmcsIG9wdGlvbnM/LndyYXBUIHx8IHRocmVlLkNsYW1wVG9FZGdlV3JhcHBpbmcsIG9wdGlvbnM/Lm1hZ0ZpbHRlciB8fCB0aHJlZS5MaW5lYXJGaWx0ZXIsIG9wdGlvbnM/Lm1pbkZpbHRlciB8fCB0aHJlZS5MaW5lYXJGaWx0ZXIsIG9wdGlvbnM/LmFuaXNvdHJvcHkgfHwgMSwgXG4gICAgICAgICAgICAvLyBmaXhlZCB2YWx1ZVxuICAgICAgICAgICAgdGhyZWUuTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICAgICAgLy8gc2V0IHRoaXMgYWZ0ZXJ3YXJkcywgd2UgY2FuJ3Qgc2V0IGl0IGluIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5nZW5lcmF0ZU1pcG1hcHMgPSBvcHRpb25zPy5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnM/LmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB1c2luZyBhIGRpc3Bvc2FibGUgcmVuZGVyZXIsIGl0IHdpbGwgZGlzcG9zZSBpdC5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVySXNEaXNwb3NhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmZvcmNlQ29udGV4dExvc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBkaXNwb3NlIG9mICoqYWxsKiogYXNzZXRzIHVzZWQgYnkgdGhpcyByZW5kZXJlci5cbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRpc3Bvc2VSZW5kZXJUYXJnZXQgd2lsbCBkaXNwb3NlIG9mIHRoZSByZW5kZXJUYXJnZXQgd2hpY2ggd2lsbCBub3QgYmUgdXNhYmxlIGxhdGVyXG4gICAgICAgICAqIHNldCB0aGlzIHRvIHRydWUgaWYgeW91IHBhc3NlZCB0aGUgYHJlbmRlclRhcmdldC50ZXh0dXJlYCB0byBhIGBQTVJFTUdlbmVyYXRvcmBcbiAgICAgICAgICogb3IgYXJlIG90aGVyd2lzZSBkb25lIHdpdGggaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYGpzXG4gICAgICAgICAqIGNvbnN0IGxvYWRlciA9IG5ldyBIRFJKUEdMb2FkZXIocmVuZGVyZXIpXG4gICAgICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoJ2dhaW5tYXAuanBlZycpXG4gICAgICAgICAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChnZW9tZXRyeSwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmUgfSkgKVxuICAgICAgICAgKiAvLyBETyBOT1QgZGlzcG9zZSB0aGUgcmVuZGVyVGFyZ2V0IGhlcmUsXG4gICAgICAgICAqIC8vIGl0IGlzIHVzZWQgZGlyZWN0bHkgaW4gdGhlIG1hdGVyaWFsXG4gICAgICAgICAqIHJlc3VsdC5kaXNwb3NlKClcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYGpzXG4gICAgICAgICAqIGNvbnN0IGxvYWRlciA9IG5ldyBIRFJKUEdMb2FkZXIocmVuZGVyZXIpXG4gICAgICAgICAqIGNvbnN0IHBtcmVtR2VuZXJhdG9yID0gbmV3IFBNUkVNR2VuZXJhdG9yKCByZW5kZXJlciApO1xuICAgICAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCdnYWlubWFwLmpwZWcnKVxuICAgICAgICAgKiBjb25zdCBlbnZNYXAgPSBwbXJlbUdlbmVyYXRvci5mcm9tRXF1aXJlY3Rhbmd1bGFyKHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSlcbiAgICAgICAgICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKGdlb21ldHJ5LCBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoeyBlbnZNYXAgfSkgKVxuICAgICAgICAgKiAvLyByZW5kZXJUYXJnZXQgY2FuIGJlIGRpc3Bvc2VkIGhlcmVcbiAgICAgICAgICogLy8gYmVjYXVzZSBpdCB3YXMgdXNlZCB0byBnZW5lcmF0ZSBhIFBNUkVNIHRleHR1cmVcbiAgICAgICAgICogcmVzdWx0LmRpc3Bvc2UodHJ1ZSlcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlKGRpc3Bvc2VSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgICAgIGlmIChkaXNwb3NlUmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGlzcG9zZSBzaGFkZXIgbWF0ZXJpYWwgdGV4dHVyZSB1bmlmb3Jtc1xuICAgICAgICAgICAgaWYgKHRoaXMubWF0ZXJpYWwgaW5zdGFuY2VvZiB0aHJlZS5TaGFkZXJNYXRlcmlhbCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5tYXRlcmlhbC51bmlmb3JtcykuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYudmFsdWUgaW5zdGFuY2VvZiB0aHJlZS5UZXh0dXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdi52YWx1ZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkaXNwb3NlIG90aGVyIG1hdGVyaWFsIHByb3BlcnRpZXNcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5tYXRlcmlhbCkuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhyZWUuVGV4dHVyZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3F1YWQuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWR0aCBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5fd2lkdGg7IH1cbiAgICAgICAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0LnNldFNpemUodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlaWdodCBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMuX2hlaWdodDsgfVxuICAgICAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRhcmdldC5zZXRTaXplKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVuZGVyZXIgdXNlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHJlbmRlcmVyKCkgeyByZXR1cm4gdGhpcy5fcmVuZGVyZXI7IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgV2ViR0xSZW5kZXJUYXJnZXRgIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgcmVuZGVyVGFyZ2V0KCkgeyByZXR1cm4gdGhpcy5fcmVuZGVyVGFyZ2V0OyB9XG4gICAgICAgIHNldCByZW5kZXJUYXJnZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlLmhlaWdodDtcbiAgICAgICAgICAgIC8vIHRoaXMuX3R5cGUgPSB2YWx1ZS50ZXh0dXJlLnR5cGVcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBNYXRlcmlhbGAgdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBtYXRlcmlhbCgpIHsgcmV0dXJuIHRoaXMuX21hdGVyaWFsOyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLl90eXBlOyB9XG4gICAgICAgIGdldCBjb2xvclNwYWNlKCkgeyByZXR1cm4gdGhpcy5fY29sb3JTcGFjZTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNoYXJlZCBkZWNvZGUgaW1wbGVtZW50YXRpb24gZmFjdG9yeVxuICAgICAqIENyZWF0ZXMgYSBkZWNvZGUgZnVuY3Rpb24gdGhhdCBwcmVwYXJlcyBhIFF1YWRSZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRGVjb2RlRnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHJldHVybiAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHNkciwgZ2Fpbk1hcCwgcmVuZGVyZXIgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmIChzZHIuY29sb3JTcGFjZSAhPT0gdGhyZWUuU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1NEUiBDb2xvcnNwYWNlIG5lZWRzIHRvIGJlICpTUkdCQ29sb3JTcGFjZSosIHNldHRpbmcgaXQgYXV0b21hdGljYWxseScpO1xuICAgICAgICAgICAgICAgIHNkci5jb2xvclNwYWNlID0gdGhyZWUuU1JHQkNvbG9yU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGdhaW5NYXAuY29sb3JTcGFjZSAhPT0gdGhyZWUuTGluZWFyU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dhaW5tYXAgQ29sb3JzcGFjZSBuZWVkcyB0byBiZSAqTGluZWFyU1JHQkNvbG9yU3BhY2UqLCBzZXR0aW5nIGl0IGF1dG9tYXRpY2FsbHknKTtcbiAgICAgICAgICAgICAgICBnYWluTWFwLmNvbG9yU3BhY2UgPSB0aHJlZS5MaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdhaW5NYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBjb25maWcuY3JlYXRlTWF0ZXJpYWwoe1xuICAgICAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgICAgICBzZHIsXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBxdWFkUmVuZGVyZXIgPSBjb25maWcuY3JlYXRlUXVhZFJlbmRlcmVyKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogc2RyLmltYWdlLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogc2RyLmltYWdlLmhlaWdodCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aHJlZS5IYWxmRmxvYXRUeXBlLFxuICAgICAgICAgICAgICAgIGNvbG9yU3BhY2U6IHRocmVlLkxpbmVhclNSR0JDb2xvclNwYWNlLFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldE9wdGlvbnM6IHBhcmFtcy5yZW5kZXJUYXJnZXRPcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBxdWFkUmVuZGVyZXI7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY2xhc3MgR2Fpbk1hcE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgfVxuXG4gICAgY2xhc3MgWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIH1cblxuICAgIGNvbnN0IGdldFhNTFZhbHVlID0gKHhtbCwgdGFnLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGF0dHJpYnV0ZSBmb3JtYXQgZmlyc3Q6IHRhZz1cInZhbHVlXCJcbiAgICAgICAgY29uc3QgYXR0cmlidXRlTWF0Y2ggPSBuZXcgUmVnRXhwKGAke3RhZ309XCIoW15cIl0qKVwiYCwgJ2knKS5leGVjKHhtbCk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVNYXRjaClcbiAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVNYXRjaFsxXTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHRhZyBmb3JtYXQ6IDx0YWc+dmFsdWU8L3RhZz4gb3IgPHRhZz48cmRmOmxpPnZhbHVlPC9yZGY6bGk+Li4uPC90YWc+XG4gICAgICAgIGNvbnN0IHRhZ01hdGNoID0gbmV3IFJlZ0V4cChgPCR7dGFnfVtePl0qPihbXFxcXHNcXFxcU10qPyk8LyR7dGFnfT5gLCAnaScpLmV4ZWMoeG1sKTtcbiAgICAgICAgaWYgKHRhZ01hdGNoKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCBjb250YWlucyByZGY6bGkgZWxlbWVudHNcbiAgICAgICAgICAgIGNvbnN0IGxpVmFsdWVzID0gdGFnTWF0Y2hbMV0ubWF0Y2goLzxyZGY6bGk+KFtePF0qKTxcXC9yZGY6bGk+L2cpO1xuICAgICAgICAgICAgaWYgKGxpVmFsdWVzICYmIGxpVmFsdWVzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaVZhbHVlcy5tYXAodiA9PiB2LnJlcGxhY2UoLzxcXC8/cmRmOmxpPi9nLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhZ01hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGZpbmQgJHt0YWd9IGluIGdhaW5tYXAgbWV0YWRhdGFgKTtcbiAgICB9O1xuICAgIGNvbnN0IGV4dHJhY3RYTVAgPSAoaW5wdXQpID0+IHtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgLy8gc3VwcG9ydCBub2RlIHRlc3QgZW52aXJvbm1lbnRcbiAgICAgICAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBzdHIgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoaW5wdXQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdHIgPSBpbnB1dC50b1N0cmluZygpO1xuICAgICAgICBsZXQgc3RhcnQgPSBzdHIuaW5kZXhPZignPHg6eG1wbWV0YScpO1xuICAgICAgICB3aGlsZSAoc3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBzdHIuaW5kZXhPZigneDp4bXBtZXRhPicsIHN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IHhtcEJsb2NrID0gc3RyLnNsaWNlKHN0YXJ0LCBlbmQgKyAxMCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhaW5NYXBNaW4gPSBnZXRYTUxWYWx1ZSh4bXBCbG9jaywgJ2hkcmdtOkdhaW5NYXBNaW4nLCAnMCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhaW5NYXBNYXggPSBnZXRYTUxWYWx1ZSh4bXBCbG9jaywgJ2hkcmdtOkdhaW5NYXBNYXgnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnYW1tYSA9IGdldFhNTFZhbHVlKHhtcEJsb2NrLCAnaGRyZ206R2FtbWEnLCAnMScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFNEUiA9IGdldFhNTFZhbHVlKHhtcEJsb2NrLCAnaGRyZ206T2Zmc2V0U0RSJywgJzAuMDE1NjI1Jyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0SERSID0gZ2V0WE1MVmFsdWUoeG1wQmxvY2ssICdoZHJnbTpPZmZzZXRIRFInLCAnMC4wMTU2MjUnKTtcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgYWx3YXlzIGF0dHJpYnV0ZXMsIHNvIHdlIGNhbiB1c2UgYSBzaW1wbGVyIHJlZ2V4XG4gICAgICAgICAgICAgICAgY29uc3QgaGRyQ2FwYWNpdHlNaW5NYXRjaCA9IC9oZHJnbTpIRFJDYXBhY2l0eU1pbj1cIihbXlwiXSopXCIvLmV4ZWMoeG1wQmxvY2spO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhkckNhcGFjaXR5TWluID0gaGRyQ2FwYWNpdHlNaW5NYXRjaCA/IGhkckNhcGFjaXR5TWluTWF0Y2hbMV0gOiAnMCc7XG4gICAgICAgICAgICAgICAgY29uc3QgaGRyQ2FwYWNpdHlNYXhNYXRjaCA9IC9oZHJnbTpIRFJDYXBhY2l0eU1heD1cIihbXlwiXSopXCIvLmV4ZWMoeG1wQmxvY2spO1xuICAgICAgICAgICAgICAgIGlmICghaGRyQ2FwYWNpdHlNYXhNYXRjaClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBsZXRlIGdhaW5tYXAgbWV0YWRhdGEnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZHJDYXBhY2l0eU1heCA9IGhkckNhcGFjaXR5TWF4TWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZ2Fpbk1hcE1pbjogQXJyYXkuaXNBcnJheShnYWluTWFwTWluKSA/IGdhaW5NYXBNaW4ubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChnYWluTWFwTWluKSwgcGFyc2VGbG9hdChnYWluTWFwTWluKSwgcGFyc2VGbG9hdChnYWluTWFwTWluKV0sXG4gICAgICAgICAgICAgICAgICAgIGdhaW5NYXBNYXg6IEFycmF5LmlzQXJyYXkoZ2Fpbk1hcE1heCkgPyBnYWluTWFwTWF4Lm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQoZ2Fpbk1hcE1heCksIHBhcnNlRmxvYXQoZ2Fpbk1hcE1heCksIHBhcnNlRmxvYXQoZ2Fpbk1hcE1heCldLFxuICAgICAgICAgICAgICAgICAgICBnYW1tYTogQXJyYXkuaXNBcnJheShnYW1tYSkgPyBnYW1tYS5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KGdhbW1hKSwgcGFyc2VGbG9hdChnYW1tYSksIHBhcnNlRmxvYXQoZ2FtbWEpXSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0U2RyOiBBcnJheS5pc0FycmF5KG9mZnNldFNEUikgPyBvZmZzZXRTRFIubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChvZmZzZXRTRFIpLCBwYXJzZUZsb2F0KG9mZnNldFNEUiksIHBhcnNlRmxvYXQob2Zmc2V0U0RSKV0sXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEhkcjogQXJyYXkuaXNBcnJheShvZmZzZXRIRFIpID8gb2Zmc2V0SERSLm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQob2Zmc2V0SERSKSwgcGFyc2VGbG9hdChvZmZzZXRIRFIpLCBwYXJzZUZsb2F0KG9mZnNldEhEUildLFxuICAgICAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1pbjogcGFyc2VGbG9hdChoZHJDYXBhY2l0eU1pbiksXG4gICAgICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWF4OiBwYXJzZUZsb2F0KGhkckNhcGFjaXR5TWF4KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHNlYXJjaGluZyBmb3IgYW5vdGhlciB4bXBtZXRhIGJsb2NrIGlmIHRoaXMgb25lIGZhaWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IHN0ci5pbmRleE9mKCc8eDp4bXBtZXRhJywgZW5kKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNUEYgRXh0cmFjdG9yIChNdWx0aSBQaWN0dXJlIEZvcm1hdCBFeHRyYWN0b3IpXG4gICAgICogQnkgSGVucmlrIFMgTmlsc3NvbiAyMDE5XG4gICAgICpcbiAgICAgKiBFeHRyYWN0cyBpbWFnZXMgc3RvcmVkIGluIGltYWdlcyBiYXNlZCBvbiB0aGUgTVBGIGZvcm1hdCAoZm91bmQgaGVyZTogaHR0cHM6Ly93d3cuY2lwYS5qcC9lL3N0ZC9zdGQtc2VjLmh0bWxcbiAgICAgKiB1bmRlciBcIkNJUEEgREMtMDA3LVRyYW5zbGF0aW9uLTIwMjEgTXVsdGktUGljdHVyZSBGb3JtYXRcIlxuICAgICAqXG4gICAgICogT3Zlcmx5IGNvbW1lbnRlZCwgYW5kIHdpdGhvdXQgaW50ZW50aW9uIG9mIGJlaW5nIGNvbXBsZXRlIG9yIHByb2R1Y3Rpb24gcmVhZHkuXG4gICAgICogQ3JlYXRlZCB0byBleHRyYWN0IGRlcHRoIG1hcHMgZnJvbSBpUGhvbmUgaW1hZ2VzLCBhbmQgdG8gbGVhcm4gYWJvdXQgaW1hZ2UgbWV0YWRhdGEuXG4gICAgICogS3Vkb3MgdG86IFBoaWwgSGFydmV5IChleGlmdG9vbCksIEphdW1lIFNhbmNoZXogKGFuZHJvaWQtbGVucy1ibHVyLWRlcHRoLWV4dHJhY3RvcilcbiAgICAgKi9cbiAgICBjbGFzcyBNUEZFeHRyYWN0b3Ige1xuICAgICAgICBvcHRpb25zO1xuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZGVidWc6IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWJ1ZyA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGV4dHJhY3RGSUk6IG9wdGlvbnMgJiYgb3B0aW9ucy5leHRyYWN0RklJICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmV4dHJhY3RGSUkgOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4dHJhY3ROb25GSUk6IG9wdGlvbnMgJiYgb3B0aW9ucy5leHRyYWN0Tm9uRklJICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmV4dHJhY3ROb25GSUkgOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhY3QoaW1hZ2VBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWJ1ZyA9IHRoaXMub3B0aW9ucy5kZWJ1ZztcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhpbWFnZUFycmF5QnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgLy8gSWYgeW91J3JlIGV4ZWN1dGluZyB0aGlzIGxpbmUgb24gYSBiaWcgZW5kaWFuIG1hY2hpbmUsIGl0J2xsIGJlIHJldmVyc2VkLlxuICAgICAgICAgICAgICAgIC8vIGJpZ0VuZCBmdXJ0aGVyIGRvd24gdGhvdWdoLCByZWZlcnMgdG8gdGhlIGVuZGlhbm5lc3Mgb2YgdGhlIGltYWdlIGl0c2VsZi5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KDApICE9PSAweGZmZDgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm90IGEgdmFsaWQganBlZycpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhVmlldy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAyO1xuICAgICAgICAgICAgICAgIGxldCBsb29wcyA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmtlcjsgLy8gQVBQIyBtYXJrZXJcbiAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2xvb3BzID4gMjUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGb3VuZCBubyBtYXJrZXIgYWZ0ZXIgJHtsb29wc30gbG9vcHMg8J+YtWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSAhPT0gMHhmZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgTm90IGEgdmFsaWQgbWFya2VyIGF0IG9mZnNldCAweCR7b2Zmc2V0LnRvU3RyaW5nKDE2KX0sIGZvdW5kOiAweCR7ZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KS50b1N0cmluZygxNil9YCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlciA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTWFya2VyOiAke21hcmtlci50b1N0cmluZygxNil9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IDB4ZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgQVBQMiBtYXJrZXIgKDB4ZmZlMiknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvcmtzIGZvciBpUGhvbmUgOCBQbHVzLCBYLCBhbmQgWFNNYXguIE9yIGFueSBwaG90b3Mgb2YgTVBGIGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdyZWF0IHdheSB0byB2aXN1YWxpemUgaW1hZ2UgaW5mb3JtYXRpb24gaW4gaHRtbCBpcyB1c2luZyBFeGlmdG9vbC4gRS5nLjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4vZXhpZnRvb2wuZXhlIC1odG1sZHVtcCAtd2FudFRyYWlsZXIgcGhvdG8uanBnID4gcGhvdG8uaHRtbFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0UHQgPSBvZmZzZXQgKyA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICBTdHJ1Y3R1cmUgb2YgdGhlIE1QIEZvcm1hdCBJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogIE9mZnNldCBBZGRyLiAgfCBDb2RlIChIZXgpICB8IERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgKzAwICAgICAgICAgICAgIGZmICAgICAgICAgICAgTWFya2VyIFByZWZpeCAgICAgIDwtLSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICArMDEgICAgICAgICAgICAgZTIgICAgICAgICAgICBBUFAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgKzAyICAgICAgICAgICAgICNuICAgICAgICAgICAgQVBQMiBGaWVsZCBMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICArMDMgICAgICAgICAgICAgI24gICAgICAgICAgICBBUFAyIEZpZWxkIExlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICogICswNCAgICAgICAgICAgICA0ZCAgICAgICAgICAgICdNJyAgICAgICAgICAgICAgICA8LS0gZm9ybWF0UHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICArMDUgICAgICAgICAgICAgNTAgICAgICAgICAgICAnUCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICArMDYgICAgICAgICAgICAgNDYgICAgICAgICAgICAnRidcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICArMDcgICAgICAgICAgICAgMDAgICAgICAgICAgICBOVUxMXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwtLSB0aWZmT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MzIoZm9ybWF0UHQpID09PSAweDRkNTA0NjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgTVBGIHRhZywgc28gd2Ugc3RhcnQgZGlnIG91dCBzdWIgaW1hZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlmZk9mZnNldCA9IGZvcm1hdFB0ICsgNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmlnRW5kOyAvLyBFbmRpYW5uZXNzIGZyb20gVElGRiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUZXN0IGZvciBUSUZGIHZhbGlkaXR5IGFuZCBlbmRpYW5uZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMHg0OTQ5IGFuZCAweDRENEQgKCdJSScgYW5kICdNTScpIG1hcmtzIExpdHRsZSBFbmRpYW4gYW5kIEJpZyBFbmRpYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDQ5NDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlnRW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0ZDRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpZ0VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdObyB2YWxpZCBlbmRpYW5uZXNzIG1hcmtlciBmb3VuZCBpbiBUSUZGIGhlYWRlcicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQgKyAyLCAhYmlnRW5kKSAhPT0gMHgwMDJhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCB2YWxpZCBUSUZGIGRhdGEhIChubyAweDAwMkEgbWFya2VyKScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzMiBiaXQgbnVtYmVyIHN0YXRpbmcgdGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgOCBCeXRlIE1QIEhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIE1QIEluZGV4IElGRCBMZWFzdCBwb3NzaWJsZSB2YWx1ZSBpcyB0aHVzIDggKG1lYW5zIDAgb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0SUZET2Zmc2V0ID0gZGF0YVZpZXcuZ2V0VWludDMyKHRpZmZPZmZzZXQgKyA0LCAhYmlnRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RJRkRPZmZzZXQgPCAweDAwMDAwMDA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCB2YWxpZCBUSUZGIGRhdGEhIChGaXJzdCBvZmZzZXQgbGVzcyB0aGFuIDgpJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgYWhlYWQgdG8gTVAgSW5kZXggSUZEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIHdlJ3JlIGF0IHRoZSBmaXJzdCBJRkQsIHNvIGZpcnN0SUZET2Zmc2V0IHBvaW50cyB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1QIEluZGV4IElGRCBhbmQgbm90IE1QIEF0dHJpYnV0ZXMgSUZELiAoSWYgd2UgdHJ5IGV4dHJhY3QgZnJvbSBhIHN1YiBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmYWlsIHNpbGVudGx5IGhlcmUgZHVlIHRvIHRoaXMgYXNzdW1wdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCAoMiBCeXRlKSB8IE1QIEluZGV4IEZpZWxkcyBhLmsuYS4gTVAgRW50cmllcyAoY291bnQgKiAxMiBCeXRlKSB8IE9mZnNldCBvZiBOZXh0IElGRCAoNCBCeXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpclN0YXJ0ID0gdGlmZk9mZnNldCArIGZpcnN0SUZET2Zmc2V0OyAvLyBTdGFydCBvZiBJRkQgKEltYWdlIEZpbGUgRGlyZWN0b3J5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gZGF0YVZpZXcuZ2V0VWludDE2KGRpclN0YXJ0LCAhYmlnRW5kKTsgLy8gQ291bnQgb2YgTVBFbnRyaWVzICgyIEJ5dGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBpbmZvIGZyb20gTVBFbnRyaWVzIChzdGFydGluZyBhZnRlciBDb3VudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzU3RhcnQgPSBkaXJTdGFydCArIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG51bWJlck9mSW1hZ2VzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZW50cmllc1N0YXJ0OyBpIDwgZW50cmllc1N0YXJ0ICsgMTIgKiBjb3VudDsgaSArPSAxMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIGVudHJ5IGlzIDEyIEJ5dGVzIGxvbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgTVAgSW5kZXggSUZEIHRhZ3MsIGhlcmUgd2Ugb25seSB0YWtlIHRhZyAweGIwMDEgPSBOdW1iZXIgb2YgaW1hZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYoaSwgIWJpZ0VuZCkgPT09IDB4YjAwMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmVkIGluIExhc3QgNCBieXRlcyBvZiBpdHMgMTIgQnl0ZSBlbnRyeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlck9mSW1hZ2VzID0gZGF0YVZpZXcuZ2V0VWludDMyKGkgKyA4LCAhYmlnRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0SUZET2Zmc2V0TGVuID0gNDsgLy8gNCBCeXRlIG9mZnNldCBmaWVsZCB0aGF0IGFwcGVhcnMgYWZ0ZXIgTVAgSW5kZXggSUZEIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBNUEltYWdlTGlzdFZhbFB0ID0gZGlyU3RhcnQgKyAyICsgY291bnQgKiAxMiArIG5leHRJRkRPZmZzZXRMZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IE1QSW1hZ2VMaXN0VmFsUHQ7IGkgPCBNUEltYWdlTGlzdFZhbFB0ICsgbnVtYmVyT2ZJbWFnZXMgKiAxNjsgaSArPSAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1QVHlwZTogZGF0YVZpZXcuZ2V0VWludDMyKGksICFiaWdFbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogZGF0YVZpZXcuZ2V0VWludDMyKGkgKyA0LCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgb2Zmc2V0IGlzIHNwZWNpZmllZCByZWxhdGl2ZSB0byB0aGUgYWRkcmVzcyBvZiB0aGUgTVAgRW5kaWFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWVsZCBpbiB0aGUgTVAgSGVhZGVyLCB1bmxlc3MgdGhlIGltYWdlIGlzIGEgRmlyc3QgSW5kaXZpZHVhbCBJbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHdoaWNoIGNhc2UgdGhlIHZhbHVlIG9mIHRoZSBvZmZzZXQgc2hhbGwgYmUgTlVMTCAoMHgwMDAwMDAwMCkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhT2Zmc2V0OiBkYXRhVmlldy5nZXRVaW50MzIoaSArIDgsICFiaWdFbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kYW50SW1hZ2VzOiBkYXRhVmlldy5nZXRVaW50MzIoaSArIDEyLCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZJSTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWFnZS5kYXRhT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhT2Zmc2V0IGlzIDB4MDAwMDAwMDAgZm9yIEZpcnN0IEluZGl2aWR1YWwgSW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLmlzRklJID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnN0YXJ0ID0gdGlmZk9mZnNldCArIGltYWdlLmRhdGFPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5pc0ZJSSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLmVuZCA9IGltYWdlLnN0YXJ0ICsgaW1hZ2Uuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLnB1c2goaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dHJhY3ROb25GSUkgJiYgaW1hZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJCbG9iID0gbmV3IEJsb2IoW2RhdGFWaWV3XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5pc0ZJSSAmJiAhdGhpcy5vcHRpb25zLmV4dHJhY3RGSUkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCBGSUlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlQmxvYiA9IGJ1ZmZlckJsb2Iuc2xpY2UoaW1hZ2Uuc3RhcnQsIGltYWdlLmVuZCArIDEsICdpbWFnZS9qcGVnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IGltYWdlVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChpbWFnZUJsb2IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbWFnZS5pbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2UuaW1nLnNyYyA9IGltYWdlVXJsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWdzLnB1c2goaW1hZ2VCbG9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGltZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMiArIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIFhNUCBNZXRhZGF0YSBhbmQgdGhlIGdhaW4gbWFwIHJlY292ZXJ5IGltYWdlXG4gICAgICogZnJvbSBhIHNpbmdsZSBKUEVHIGZpbGUuXG4gICAgICpcbiAgICAgKiBAY2F0ZWdvcnkgRGVjb2RpbmcgRnVuY3Rpb25zXG4gICAgICogQGdyb3VwIERlY29kaW5nIEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSBqcGVnRmlsZSBhbiBgVWludDhBcnJheWAgY29udGFpbmluZyBhbmQgZW5jb2RlZCBKUEVHIGZpbGVcbiAgICAgKiBAcmV0dXJucyBhbiBzZHIgYFVpbnQ4QXJyYXlgIGNvbXByZXNzZWQgaW4gSlBFRywgYSBnYWluTWFwIGBVaW50OEFycmF5YCBjb21wcmVzc2VkIGluIEpQRUcgYW5kIHRoZSBYTVAgcGFyc2VkIFhNUCBtZXRhZGF0YVxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgWE1QIE1ldGFkYXRhIGlzIG5vdCBmb3VuZFxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgR2FpbiBtYXAgaW1hZ2UgaXMgbm90IGZvdW5kXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbXBvcnQgeyBGaWxlTG9hZGVyIH0gZnJvbSAndGhyZWUnXG4gICAgICogaW1wb3J0IHsgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyB9IGZyb20gJ0Btb25vZ3JpZC9nYWlubWFwLWpzJ1xuICAgICAqXG4gICAgICogY29uc3QganBlZ0ZpbGUgPSBhd2FpdCBuZXcgRmlsZUxvYWRlcigpXG4gICAgICogIC5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJylcbiAgICAgKiAgLmxvYWRBc3luYygnaW1hZ2UuanBnJylcbiAgICAgKlxuICAgICAqIGNvbnN0IHsgc2RyLCBnYWluTWFwLCBtZXRhZGF0YSB9ID0gZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyhqcGVnRmlsZSlcbiAgICAgKi9cbiAgICBjb25zdCBleHRyYWN0R2Fpbm1hcEZyb21KUEVHID0gYXN5bmMgKGpwZWdGaWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZXh0cmFjdFhNUChqcGVnRmlsZSk7XG4gICAgICAgIGlmICghbWV0YWRhdGEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yKCdHYWluIG1hcCBYTVAgbWV0YWRhdGEgbm90IGZvdW5kJyk7XG4gICAgICAgIGNvbnN0IG1wZkV4dHJhY3RvciA9IG5ldyBNUEZFeHRyYWN0b3IoeyBleHRyYWN0RklJOiB0cnVlLCBleHRyYWN0Tm9uRklJOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBpbWFnZXMgPSBhd2FpdCBtcGZFeHRyYWN0b3IuZXh0cmFjdChqcGVnRmlsZSk7XG4gICAgICAgIGlmIChpbWFnZXMubGVuZ3RoICE9PSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEdhaW5NYXBOb3RGb3VuZEVycm9yKCdHYWluIG1hcCByZWNvdmVyeSBpbWFnZSBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNkcjogbmV3IFVpbnQ4QXJyYXkoYXdhaXQgaW1hZ2VzWzBdLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICAgICAgZ2Fpbk1hcDogbmV3IFVpbnQ4QXJyYXkoYXdhaXQgaW1hZ2VzWzFdLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZSBmdW5jdGlvbiwgYXN5bmMgZ2V0IGltYWdlIGZyb20gYmxvYlxuICAgICAqXG4gICAgICogQHBhcmFtIGJsb2JcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNvbnN0IGdldEhUTUxJbWFnZUZyb21CbG9iID0gKGJsb2IpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHsgcmVzb2x2ZShpbWcpOyB9O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXG4gICAgICAgICAgICBpbWcub25lcnJvciA9IChlKSA9PiB7IHJlamVjdChlKTsgfTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hhcmVkIGJhc2UgY2xhc3MgZm9yIGxvYWRlcnMgdGhhdCBleHRyYWN0cyBjb21tb24gbG9naWNcbiAgICAgKi9cbiAgICBjbGFzcyBMb2FkZXJCYXNlU2hhcmVkIGV4dGVuZHMgdGhyZWUuTG9hZGVyIHtcbiAgICAgICAgX3JlbmRlcmVyO1xuICAgICAgICBfcmVuZGVyVGFyZ2V0T3B0aW9ucztcbiAgICAgICAgX2ludGVybmFsTG9hZGluZ01hbmFnZXI7XG4gICAgICAgIF9jb25maWc7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgbWFuYWdlcikge1xuICAgICAgICAgICAgc3VwZXIobWFuYWdlcik7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnJlbmRlcmVyKVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gY29uZmlnLnJlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlciA9IG5ldyB0aHJlZS5Mb2FkaW5nTWFuYWdlcigpO1xuICAgICAgICB9XG4gICAgICAgIHNldFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UmVuZGVyVGFyZ2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHByZXBhcmVRdWFkUmVuZGVyZXIoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBBIFJlbmRlcmVyIHdhcyBub3QgcGFzc2VkIHRvIHRoaXMgTG9hZGVyIGNvbnN0cnVjdG9yIG9yIGluIHNldFJlbmRlcmVyLCB0aGUgcmVzdWx0IG9mIHRoaXMgTG9hZGVyIHdpbGwgbmVlZCB0byBiZSBjb252ZXJ0ZWQgdG8gYSBEYXRhIFRleHR1cmUgd2l0aCB0b0RhdGFUZXh0dXJlKCkgYmVmb3JlIHlvdSBjYW4gdXNlIGl0IGluIHlvdXIgcmVuZGVyZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXRlcmlhbCA9IHRoaXMuX2NvbmZpZy5jcmVhdGVNYXRlcmlhbCh7XG4gICAgICAgICAgICAgICAgZ2Fpbk1hcE1heDogWzEsIDEsIDFdLFxuICAgICAgICAgICAgICAgIGdhaW5NYXBNaW46IFswLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBnYW1tYTogWzEsIDEsIDFdLFxuICAgICAgICAgICAgICAgIG9mZnNldEhkcjogWzEsIDEsIDFdLFxuICAgICAgICAgICAgICAgIG9mZnNldFNkcjogWzEsIDEsIDFdLFxuICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWF4OiAxLFxuICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWluOiAwLFxuICAgICAgICAgICAgICAgIG1heERpc3BsYXlCb29zdDogMSxcbiAgICAgICAgICAgICAgICBnYWluTWFwOiBuZXcgdGhyZWUuVGV4dHVyZSgpLFxuICAgICAgICAgICAgICAgIHNkcjogbmV3IHRocmVlLlRleHR1cmUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnLmNyZWF0ZVF1YWRSZW5kZXJlcih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDE2LFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTYsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhyZWUuSGFsZkZsb2F0VHlwZSxcbiAgICAgICAgICAgICAgICBjb2xvclNwYWNlOiB0aHJlZS5MaW5lYXJTUkdCQ29sb3JTcGFjZSxcbiAgICAgICAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogdGhpcy5fcmVuZGVyZXIsXG4gICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0T3B0aW9uczogdGhpcy5fcmVuZGVyVGFyZ2V0T3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcHJvY2Vzc0ltYWdlcyhzZHJCdWZmZXIsIGdhaW5NYXBCdWZmZXIsIGltYWdlT3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGdhaW5NYXBCbG9iID0gZ2Fpbk1hcEJ1ZmZlciA/IG5ldyBCbG9iKFtnYWluTWFwQnVmZmVyXSwgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBzZHJCbG9iID0gbmV3IEJsb2IoW3NkckJ1ZmZlcl0sIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pO1xuICAgICAgICAgICAgbGV0IHNkckltYWdlO1xuICAgICAgICAgICAgbGV0IGdhaW5NYXBJbWFnZTtcbiAgICAgICAgICAgIGxldCBuZWVkc0ZsaXAgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICBnYWluTWFwQmxvYiA/IGdldEhUTUxJbWFnZUZyb21CbG9iKGdhaW5NYXBCbG9iKSA6IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICBnZXRIVE1MSW1hZ2VGcm9tQmxvYihzZHJCbG9iKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGdhaW5NYXBJbWFnZSA9IHJlc1swXTtcbiAgICAgICAgICAgICAgICBzZHJJbWFnZSA9IHJlc1sxXTtcbiAgICAgICAgICAgICAgICBuZWVkc0ZsaXAgPSBpbWFnZU9yaWVudGF0aW9uID09PSAnZmxpcFknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICBnYWluTWFwQmxvYiA/IGNyZWF0ZUltYWdlQml0bWFwKGdhaW5NYXBCbG9iLCB7IGltYWdlT3JpZW50YXRpb246IGltYWdlT3JpZW50YXRpb24gfHwgJ2ZsaXBZJyB9KSA6IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVJbWFnZUJpdG1hcChzZHJCbG9iLCB7IGltYWdlT3JpZW50YXRpb246IGltYWdlT3JpZW50YXRpb24gfHwgJ2ZsaXBZJyB9KVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGdhaW5NYXBJbWFnZSA9IHJlc1swXTtcbiAgICAgICAgICAgICAgICBzZHJJbWFnZSA9IHJlc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHNkckltYWdlLCBnYWluTWFwSW1hZ2UsIG5lZWRzRmxpcCB9O1xuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZVRleHR1cmVzKHNkckltYWdlLCBnYWluTWFwSW1hZ2UsIG5lZWRzRmxpcCkge1xuICAgICAgICAgICAgY29uc3QgZ2Fpbk1hcCA9IG5ldyB0aHJlZS5UZXh0dXJlKGdhaW5NYXBJbWFnZSB8fCBuZXcgSW1hZ2VEYXRhKDIsIDIpLCB0aHJlZS5VVk1hcHBpbmcsIHRocmVlLkNsYW1wVG9FZGdlV3JhcHBpbmcsIHRocmVlLkNsYW1wVG9FZGdlV3JhcHBpbmcsIHRocmVlLkxpbmVhckZpbHRlciwgdGhyZWUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLCB0aHJlZS5SR0JBRm9ybWF0LCB0aHJlZS5VbnNpZ25lZEJ5dGVUeXBlLCAxLCB0aHJlZS5MaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgICAgICBnYWluTWFwLmZsaXBZID0gbmVlZHNGbGlwO1xuICAgICAgICAgICAgZ2Fpbk1hcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBzZHIgPSBuZXcgdGhyZWUuVGV4dHVyZShzZHJJbWFnZSwgdGhyZWUuVVZNYXBwaW5nLCB0aHJlZS5DbGFtcFRvRWRnZVdyYXBwaW5nLCB0aHJlZS5DbGFtcFRvRWRnZVdyYXBwaW5nLCB0aHJlZS5MaW5lYXJGaWx0ZXIsIHRocmVlLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciwgdGhyZWUuUkdCQUZvcm1hdCwgdGhyZWUuVW5zaWduZWRCeXRlVHlwZSwgMSwgdGhyZWUuU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICAgICAgc2RyLmZsaXBZID0gbmVlZHNGbGlwO1xuICAgICAgICAgICAgc2RyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7IGdhaW5NYXAsIHNkciB9O1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVF1YWRSZW5kZXJlcihxdWFkUmVuZGVyZXIsIHNkckltYWdlLCBnYWluTWFwLCBzZHIsIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBxdWFkUmVuZGVyZXIud2lkdGggPSBzZHJJbWFnZS53aWR0aDtcbiAgICAgICAgICAgIHF1YWRSZW5kZXJlci5oZWlnaHQgPSBzZHJJbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuZ2Fpbk1hcCA9IGdhaW5NYXA7XG4gICAgICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuc2RyID0gc2RyO1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmdhaW5NYXBNaW4gPSBtZXRhZGF0YS5nYWluTWFwTWluO1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmdhaW5NYXBNYXggPSBtZXRhZGF0YS5nYWluTWFwTWF4O1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLm9mZnNldEhkciA9IG1ldGFkYXRhLm9mZnNldEhkcjtcbiAgICAgICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5vZmZzZXRTZHIgPSBtZXRhZGF0YS5vZmZzZXRTZHI7XG4gICAgICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuZ2FtbWEgPSBtZXRhZGF0YS5nYW1tYTtcbiAgICAgICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5oZHJDYXBhY2l0eU1pbiA9IG1ldGFkYXRhLmhkckNhcGFjaXR5TWluO1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmhkckNhcGFjaXR5TWF4ID0gbWV0YWRhdGEuaGRyQ2FwYWNpdHlNYXg7XG4gICAgICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwubWF4RGlzcGxheUJvb3N0ID0gTWF0aC5wb3coMiwgbWV0YWRhdGEuaGRyQ2FwYWNpdHlNYXgpO1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IC8qIGdsc2wgKi8gYFxudmFyeWluZyB2ZWMyIHZVdjtcblxudm9pZCBtYWluKCkge1xuICB2VXYgPSB1djtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbn1cbmA7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSAvKiBnbHNsICovIGBcbi8vIG1pbiBoYWxmIGZsb2F0IHZhbHVlXG4jZGVmaW5lIEhBTEZfRkxPQVRfTUlOIHZlYzMoIC02NTUwNCwgLTY1NTA0LCAtNjU1MDQgKVxuLy8gbWF4IGhhbGYgZmxvYXQgdmFsdWVcbiNkZWZpbmUgSEFMRl9GTE9BVF9NQVggdmVjMyggNjU1MDQsIDY1NTA0LCA2NTUwNCApXG5cbnVuaWZvcm0gc2FtcGxlcjJEIHNkcjtcbnVuaWZvcm0gc2FtcGxlcjJEIGdhaW5NYXA7XG51bmlmb3JtIHZlYzMgZ2FtbWE7XG51bmlmb3JtIHZlYzMgb2Zmc2V0SGRyO1xudW5pZm9ybSB2ZWMzIG9mZnNldFNkcjtcbnVuaWZvcm0gdmVjMyBnYWluTWFwTWluO1xudW5pZm9ybSB2ZWMzIGdhaW5NYXBNYXg7XG51bmlmb3JtIGZsb2F0IHdlaWdodEZhY3RvcjtcblxudmFyeWluZyB2ZWMyIHZVdjtcblxudm9pZCBtYWluKCkge1xuICB2ZWMzIHJnYiA9IHRleHR1cmUyRCggc2RyLCB2VXYgKS5yZ2I7XG4gIHZlYzMgcmVjb3ZlcnkgPSB0ZXh0dXJlMkQoIGdhaW5NYXAsIHZVdiApLnJnYjtcbiAgdmVjMyBsb2dSZWNvdmVyeSA9IHBvdyggcmVjb3ZlcnksIGdhbW1hICk7XG4gIHZlYzMgbG9nQm9vc3QgPSBnYWluTWFwTWluICogKCAxLjAgLSBsb2dSZWNvdmVyeSApICsgZ2Fpbk1hcE1heCAqIGxvZ1JlY292ZXJ5O1xuICB2ZWMzIGhkckNvbG9yID0gKHJnYiArIG9mZnNldFNkcikgKiBleHAyKCBsb2dCb29zdCAqIHdlaWdodEZhY3RvciApIC0gb2Zmc2V0SGRyO1xuICB2ZWMzIGNsYW1wZWRIZHJDb2xvciA9IG1heCggSEFMRl9GTE9BVF9NSU4sIG1pbiggSEFMRl9GTE9BVF9NQVgsIGhkckNvbG9yICkpO1xuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjbGFtcGVkSGRyQ29sb3IgLCAxLjAgKTtcbn1cbmA7XG4gICAgLyoqXG4gICAgICogQSBNYXRlcmlhbCB3aGljaCBpcyBhYmxlIHRvIGRlY29kZSB0aGUgR2Fpbm1hcCBpbnRvIGEgZnVsbCBIRFIgUmVwcmVzZW50YXRpb25cbiAgICAgKlxuICAgICAqIEBjYXRlZ29yeSBNYXRlcmlhbHNcbiAgICAgKiBAZ3JvdXAgTWF0ZXJpYWxzXG4gICAgICovXG4gICAgY2xhc3MgR2Fpbk1hcERlY29kZXJNYXRlcmlhbCBleHRlbmRzIHRocmVlLlNoYWRlck1hdGVyaWFsIHtcbiAgICAgICAgX21heERpc3BsYXlCb29zdDtcbiAgICAgICAgX2hkckNhcGFjaXR5TWluO1xuICAgICAgICBfaGRyQ2FwYWNpdHlNYXg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3Rvcih7IGdhbW1hLCBvZmZzZXRIZHIsIG9mZnNldFNkciwgZ2Fpbk1hcE1pbiwgZ2Fpbk1hcE1heCwgbWF4RGlzcGxheUJvb3N0LCBoZHJDYXBhY2l0eU1pbiwgaGRyQ2FwYWNpdHlNYXgsIHNkciwgZ2Fpbk1hcCB9KSB7XG4gICAgICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0dhaW5NYXBEZWNvZGVyTWF0ZXJpYWwnLFxuICAgICAgICAgICAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICAgICAgICBzZHI6IHsgdmFsdWU6IHNkciB9LFxuICAgICAgICAgICAgICAgICAgICBnYWluTWFwOiB7IHZhbHVlOiBnYWluTWFwIH0sXG4gICAgICAgICAgICAgICAgICAgIGdhbW1hOiB7IHZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygxLjAgLyBnYW1tYVswXSwgMS4wIC8gZ2FtbWFbMV0sIDEuMCAvIGdhbW1hWzJdKSB9LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRIZHI6IHsgdmFsdWU6IG5ldyB0aHJlZS5WZWN0b3IzKCkuZnJvbUFycmF5KG9mZnNldEhkcikgfSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0U2RyOiB7IHZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpLmZyb21BcnJheShvZmZzZXRTZHIpIH0sXG4gICAgICAgICAgICAgICAgICAgIGdhaW5NYXBNaW46IHsgdmFsdWU6IG5ldyB0aHJlZS5WZWN0b3IzKCkuZnJvbUFycmF5KGdhaW5NYXBNaW4pIH0sXG4gICAgICAgICAgICAgICAgICAgIGdhaW5NYXBNYXg6IHsgdmFsdWU6IG5ldyB0aHJlZS5WZWN0b3IzKCkuZnJvbUFycmF5KGdhaW5NYXBNYXgpIH0sXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodEZhY3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IChNYXRoLmxvZzIobWF4RGlzcGxheUJvb3N0KSAtIGhkckNhcGFjaXR5TWluKSAvIChoZHJDYXBhY2l0eU1heCAtIGhkckNhcGFjaXR5TWluKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBibGVuZGluZzogdGhyZWUuTm9CbGVuZGluZyxcbiAgICAgICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRlcHRoV3JpdGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX21heERpc3BsYXlCb29zdCA9IG1heERpc3BsYXlCb29zdDtcbiAgICAgICAgICAgIHRoaXMuX2hkckNhcGFjaXR5TWluID0gaGRyQ2FwYWNpdHlNaW47XG4gICAgICAgICAgICB0aGlzLl9oZHJDYXBhY2l0eU1heCA9IGhkckNhcGFjaXR5TWF4O1xuICAgICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHNkcigpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2RyLnZhbHVlOyB9XG4gICAgICAgIHNldCBzZHIodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5zZHIudmFsdWUgPSB2YWx1ZTsgfVxuICAgICAgICBnZXQgZ2Fpbk1hcCgpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2Fpbk1hcC52YWx1ZTsgfVxuICAgICAgICBzZXQgZ2Fpbk1hcCh2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLmdhaW5NYXAudmFsdWUgPSB2YWx1ZTsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLm9mZnNldEhkcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldCBvZmZzZXRIZHIoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLm9mZnNldEhkci52YWx1ZS50b0FycmF5KCk7IH1cbiAgICAgICAgc2V0IG9mZnNldEhkcih2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLm9mZnNldEhkci52YWx1ZS5mcm9tQXJyYXkodmFsdWUpOyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEub2Zmc2V0U2RyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IG9mZnNldFNkcigpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMub2Zmc2V0U2RyLnZhbHVlLnRvQXJyYXkoKTsgfVxuICAgICAgICBzZXQgb2Zmc2V0U2RyKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMub2Zmc2V0U2RyLnZhbHVlLmZyb21BcnJheSh2YWx1ZSk7IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5nYWluTWFwTWlufVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGdhaW5NYXBNaW4oKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLmdhaW5NYXBNaW4udmFsdWUudG9BcnJheSgpOyB9XG4gICAgICAgIHNldCBnYWluTWFwTWluKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMuZ2Fpbk1hcE1pbi52YWx1ZS5mcm9tQXJyYXkodmFsdWUpOyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuZ2Fpbk1hcE1heH1cbiAgICAgICAgICovXG4gICAgICAgIGdldCBnYWluTWFwTWF4KCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5nYWluTWFwTWF4LnZhbHVlLnRvQXJyYXkoKTsgfVxuICAgICAgICBzZXQgZ2Fpbk1hcE1heCh2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLmdhaW5NYXBNYXgudmFsdWUuZnJvbUFycmF5KHZhbHVlKTsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLmdhbW1hfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGdhbW1hKCkge1xuICAgICAgICAgICAgY29uc3QgZyA9IHRoaXMudW5pZm9ybXMuZ2FtbWEudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gWzEgLyBnLngsIDEgLyBnLnksIDEgLyBnLnpdO1xuICAgICAgICB9XG4gICAgICAgIHNldCBnYW1tYSh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgZyA9IHRoaXMudW5pZm9ybXMuZ2FtbWEudmFsdWU7XG4gICAgICAgICAgICBnLnggPSAxLjAgLyB2YWx1ZVswXTtcbiAgICAgICAgICAgIGcueSA9IDEuMCAvIHZhbHVlWzFdO1xuICAgICAgICAgICAgZy56ID0gMS4wIC8gdmFsdWVbMl07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5oZHJDYXBhY2l0eU1pbn1cbiAgICAgICAgICogQHJlbWFya3MgTG9nYXJpdGhtaWMgc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIGdldCBoZHJDYXBhY2l0eU1pbigpIHsgcmV0dXJuIHRoaXMuX2hkckNhcGFjaXR5TWluOyB9XG4gICAgICAgIHNldCBoZHJDYXBhY2l0eU1pbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGRyQ2FwYWNpdHlNaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlV2VpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5oZHJDYXBhY2l0eU1pbn1cbiAgICAgICAgICogQHJlbWFya3MgTG9nYXJpdGhtaWMgc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIGdldCBoZHJDYXBhY2l0eU1heCgpIHsgcmV0dXJuIHRoaXMuX2hkckNhcGFjaXR5TWF4OyB9XG4gICAgICAgIHNldCBoZHJDYXBhY2l0eU1heCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGRyQ2FwYWNpdHlNYXggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlV2VpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzZWUge0BsaW5rIEdhaW5tYXBEZWNvZGluZ1BhcmFtZXRlcnMubWF4RGlzcGxheUJvb3N0fVxuICAgICAgICAgKiBAcmVtYXJrcyBOb24gTG9nYXJpdGhtaWMgc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIGdldCBtYXhEaXNwbGF5Qm9vc3QoKSB7IHJldHVybiB0aGlzLl9tYXhEaXNwbGF5Qm9vc3Q7IH1cbiAgICAgICAgc2V0IG1heERpc3BsYXlCb29zdCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbWF4RGlzcGxheUJvb3N0ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oNjU1MDQsIHZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVdlaWdodCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGN1bGF0ZVdlaWdodCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IChNYXRoLmxvZzIodGhpcy5fbWF4RGlzcGxheUJvb3N0KSAtIHRoaXMuX2hkckNhcGFjaXR5TWluKSAvICh0aGlzLl9oZHJDYXBhY2l0eU1heCAtIHRoaXMuX2hkckNhcGFjaXR5TWluKTtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMud2VpZ2h0RmFjdG9yLnZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkZWNvZGVJbXBsID0gY3JlYXRlRGVjb2RlRnVuY3Rpb24oe1xuICAgICAgICByZW5kZXJlcjogdGhyZWUuV2ViR0xSZW5kZXJlcixcbiAgICAgICAgY3JlYXRlTWF0ZXJpYWw6IChwYXJhbXMpID0+IG5ldyBHYWluTWFwRGVjb2Rlck1hdGVyaWFsKHBhcmFtcyksXG4gICAgICAgIGNyZWF0ZVF1YWRSZW5kZXJlcjogKHBhcmFtcykgPT4gbmV3IFF1YWRSZW5kZXJlcihwYXJhbXMpXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIGdhaW4gbWFwIHVzaW5nIGEgV2ViR0wgUmVuZGVyVGFyZ2V0XG4gICAgICpcbiAgICAgKiBAY2F0ZWdvcnkgRGVjb2RpbmcgRnVuY3Rpb25zXG4gICAgICogQGdyb3VwIERlY29kaW5nIEZ1bmN0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnXG4gICAgICogaW1wb3J0IHtcbiAgICAgKiAgIE1lc2gsXG4gICAgICogICBNZXNoQmFzaWNNYXRlcmlhbCxcbiAgICAgKiAgIFBlcnNwZWN0aXZlQ2FtZXJhLFxuICAgICAqICAgUGxhbmVHZW9tZXRyeSxcbiAgICAgKiAgIFNjZW5lLFxuICAgICAqICAgVGV4dHVyZUxvYWRlcixcbiAgICAgKiAgIFdlYkdMUmVuZGVyZXJcbiAgICAgKiB9IGZyb20gJ3RocmVlJ1xuICAgICAqXG4gICAgICogY29uc3QgcmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpXG4gICAgICpcbiAgICAgKiBjb25zdCB0ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoKVxuICAgICAqXG4gICAgICogLy8gbG9hZCBTRFIgUmVwcmVzZW50YXRpb25cbiAgICAgKiBjb25zdCBzZHIgPSBhd2FpdCB0ZXh0dXJlTG9hZGVyLmxvYWRBc3luYygnc2RyLmpwZycpXG4gICAgICogLy8gbG9hZCBHYWluIG1hcCByZWNvdmVyeSBpbWFnZVxuICAgICAqIGNvbnN0IGdhaW5NYXAgPSBhd2FpdCB0ZXh0dXJlTG9hZGVyLmxvYWRBc3luYygnZ2Fpbm1hcC5qcGcnKVxuICAgICAqIC8vIGxvYWQgbWV0YWRhdGFcbiAgICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IChhd2FpdCBmZXRjaCgnbWV0YWRhdGEuanNvbicpKS5qc29uKClcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3VsdCA9IGRlY29kZSh7XG4gICAgICogICBzZHIsXG4gICAgICogICBnYWluTWFwLFxuICAgICAqICAgLy8gdGhpcyBhbGxvd3MgdG8gdXNlIGByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVgIGRpcmVjdGx5XG4gICAgICogICByZW5kZXJlcixcbiAgICAgKiAgIC8vIHRoaXMgd2lsbCByZXN0b3JlIHRoZSBmdWxsIEhEUiByYW5nZVxuICAgICAqICAgbWF4RGlzcGxheUJvb3N0OiBNYXRoLnBvdygyLCBtZXRhZGF0YS5oZHJDYXBhY2l0eU1heCksXG4gICAgICogICAuLi5tZXRhZGF0YVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBjb25zdCBzY2VuZSA9IG5ldyBTY2VuZSgpXG4gICAgICogLy8gYHJlc3VsdGAgY2FuIGJlIHVzZWQgdG8gcG9wdWxhdGUgYSBUZXh0dXJlXG4gICAgICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKFxuICAgICAqICAgbmV3IFBsYW5lR2VvbWV0cnkoKSxcbiAgICAgKiAgIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlIH0pXG4gICAgICogKVxuICAgICAqIHNjZW5lLmFkZChtZXNoKVxuICAgICAqIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCkpXG4gICAgICpcbiAgICAgKiAvLyByZXN1bHQgbXVzdCBiZSBtYW51YWxseSBkaXNwb3NlZFxuICAgICAqIC8vIHdoZW4geW91IGFyZSBkb25lIHVzaW5nIGl0XG4gICAgICogcmVzdWx0LmRpc3Bvc2UoKVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqIEByZXR1cm5zXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBXZWJHTFJlbmRlcmVyIGZhaWxzIHRvIHJlbmRlciB0aGUgZ2FpbiBtYXBcbiAgICAgKi9cbiAgICBjb25zdCBkZWNvZGUgPSAocGFyYW1zKSA9PiB7XG4gICAgICAgIC8vIEVuc3VyZSByZW5kZXJlciBpcyBkZWZpbmVkIGZvciB0aGUgYmFzZSBmdW5jdGlvblxuICAgICAgICBpZiAoIXBhcmFtcy5yZW5kZXJlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlciBpcyByZXF1aXJlZCBmb3IgZGVjb2RlIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVhZFJlbmRlcmVyID0gZGVjb2RlSW1wbCh7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICByZW5kZXJlcjogcGFyYW1zLnJlbmRlcmVyXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1YWRSZW5kZXJlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQmFzZSBjbGFzcyBmb3IgV2ViR0wgbG9hZGVyc1xuICAgICAqIEB0ZW1wbGF0ZSBUVXJsIC0gVGhlIHR5cGUgb2YgVVJMIHVzZWQgdG8gbG9hZCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBjbGFzcyBMb2FkZXJCYXNlV2ViR0wgZXh0ZW5kcyBMb2FkZXJCYXNlU2hhcmVkIHtcbiAgICAgICAgY29uc3RydWN0b3IocmVuZGVyZXIsIG1hbmFnZXIpIHtcbiAgICAgICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgICAgICByZW5kZXJlcixcbiAgICAgICAgICAgICAgICBjcmVhdGVNYXRlcmlhbDogKHBhcmFtcykgPT4gbmV3IEdhaW5NYXBEZWNvZGVyTWF0ZXJpYWwocGFyYW1zKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVRdWFkUmVuZGVyZXI6IChwYXJhbXMpID0+IG5ldyBRdWFkUmVuZGVyZXIocGFyYW1zKVxuICAgICAgICAgICAgfSwgbWFuYWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSBxdWFkUmVuZGVyZXJcbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAgICAgICAqIEBwYXJhbSBzZHJCdWZmZXJcbiAgICAgICAgICogQHBhcmFtIGdhaW5NYXBCdWZmZXJcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHJlbmRlcihxdWFkUmVuZGVyZXIsIG1ldGFkYXRhLCBzZHJCdWZmZXIsIGdhaW5NYXBCdWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2RySW1hZ2UsIGdhaW5NYXBJbWFnZSwgbmVlZHNGbGlwIH0gPSBhd2FpdCB0aGlzLnByb2Nlc3NJbWFnZXMoc2RyQnVmZmVyLCBnYWluTWFwQnVmZmVyLCAnZmxpcFknKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2Fpbk1hcCwgc2RyIH0gPSB0aGlzLmNyZWF0ZVRleHR1cmVzKHNkckltYWdlLCBnYWluTWFwSW1hZ2UsIG5lZWRzRmxpcCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVF1YWRSZW5kZXJlcihxdWFkUmVuZGVyZXIsIHNkckltYWdlLCBnYWluTWFwLCBzZHIsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIHF1YWRSZW5kZXJlci5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgVGhyZWUuanMgTG9hZGVyIGZvciB0aGUgZ2FpbiBtYXAgZm9ybWF0LlxuICAgICAqXG4gICAgICogQGNhdGVnb3J5IExvYWRlcnNcbiAgICAgKiBAZ3JvdXAgTG9hZGVyc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbXBvcnQgeyBHYWluTWFwTG9hZGVyIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnXG4gICAgICogaW1wb3J0IHtcbiAgICAgKiAgIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxuICAgICAqICAgTWVzaCxcbiAgICAgKiAgIE1lc2hCYXNpY01hdGVyaWFsLFxuICAgICAqICAgUGVyc3BlY3RpdmVDYW1lcmEsXG4gICAgICogICBQbGFuZUdlb21ldHJ5LFxuICAgICAqICAgU2NlbmUsXG4gICAgICogICBXZWJHTFJlbmRlcmVyXG4gICAgICogfSBmcm9tICd0aHJlZSdcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoKVxuICAgICAqXG4gICAgICogY29uc3QgbG9hZGVyID0gbmV3IEdhaW5NYXBMb2FkZXIocmVuZGVyZXIpXG4gICAgICogICAuc2V0UmVuZGVyVGFyZ2V0T3B0aW9ucyh7IG1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nIH0pXG4gICAgICpcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKFsnc2RyLmpwZWcnLCAnZ2Fpbm1hcC5qcGVnJywgJ21ldGFkYXRhLmpzb24nXSlcbiAgICAgKiAvLyBgcmVzdWx0YCBjYW4gYmUgdXNlZCB0byBwb3B1bGF0ZSBhIFRleHR1cmVcbiAgICAgKlxuICAgICAqIGNvbnN0IHNjZW5lID0gbmV3IFNjZW5lKClcbiAgICAgKiBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gICAgICogICBuZXcgUGxhbmVHZW9tZXRyeSgpLFxuICAgICAqICAgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmUgfSlcbiAgICAgKiApXG4gICAgICogc2NlbmUuYWRkKG1lc2gpXG4gICAgICogcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKSlcbiAgICAgKlxuICAgICAqIC8vIFN0YXJ0aW5nIGZyb20gdGhyZWUuanMgcjE1OVxuICAgICAqIC8vIGByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVgIGNhblxuICAgICAqIC8vIGFsc28gYmUgdXNlZCBhcyBFcXVpcmVjdGFuZ3VsYXIgc2NlbmUgYmFja2dyb3VuZFxuICAgICAqIC8vXG4gICAgICogLy8gaXQgd2FzIHByZXZpb3VzbHkgbmVlZGVkIHRvIGNvbnZlcnQgaXRcbiAgICAgKiAvLyB0byBhIERhdGFUZXh0dXJlIHdpdGggYHJlc3VsdC50b0RhdGFUZXh0dXJlKClgXG4gICAgICogc2NlbmUuYmFja2dyb3VuZCA9IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZVxuICAgICAqXG4gICAgICogLy8gcmVzdWx0IG11c3QgYmUgbWFudWFsbHkgZGlzcG9zZWRcbiAgICAgKiAvLyB3aGVuIHlvdSBhcmUgZG9uZSB1c2luZyBpdFxuICAgICAqIHJlc3VsdC5kaXNwb3NlKClcbiAgICAgKlxuICAgICAqL1xuICAgIGNsYXNzIEdhaW5NYXBMb2FkZXIgZXh0ZW5kcyBMb2FkZXJCYXNlV2ViR0wge1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9hZHMgYSBnYWlubWFwIHVzaW5nIHNlcGFyYXRlIGRhdGFcbiAgICAgICAgICogKiBzZHIgaW1hZ2VcbiAgICAgICAgICogKiBnYWluIG1hcCBpbWFnZVxuICAgICAgICAgKiAqIG1ldGFkYXRhIGpzb25cbiAgICAgICAgICpcbiAgICAgICAgICogdXNlZnVsIGZvciB3ZWJwIGdhaW4gbWFwc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXJscyBBbiBhcnJheSBpbiB0aGUgZm9ybSBvZiBbc2RyLmpwZywgZ2Fpbm1hcC5qcGcsIG1ldGFkYXRhLmpzb25dXG4gICAgICAgICAqIEBwYXJhbSBvbkxvYWQgTG9hZCBjb21wbGV0ZSBjYWxsYmFjaywgd2lsbCByZWNlaXZlIHRoZSByZXN1bHRcbiAgICAgICAgICogQHBhcmFtIG9uUHJvZ3Jlc3MgUHJvZ3Jlc3MgY2FsbGJhY2ssIHdpbGwgcmVjZWl2ZSBhIGBQcm9ncmVzc0V2ZW50YFxuICAgICAgICAgKiBAcGFyYW0gb25FcnJvciBFcnJvciBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgbG9hZChbc2RyVXJsLCBnYWluTWFwVXJsLCBtZXRhZGF0YVVybF0sIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcXVhZFJlbmRlcmVyID0gdGhpcy5wcmVwYXJlUXVhZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICBsZXQgc2RyO1xuICAgICAgICAgICAgbGV0IGdhaW5NYXA7XG4gICAgICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgICAgICBjb25zdCBsb2FkQ2hlY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNkciAmJiBnYWluTWFwICYmIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbHZlcyAjMTZcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyKHF1YWRSZW5kZXJlciwgbWV0YWRhdGEsIHNkciwgZ2Fpbk1hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHNkclVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKGdhaW5NYXBVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uTG9hZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9hZChxdWFkUmVuZGVyZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVuZChzZHJVcmwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVuZChnYWluTWFwVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FbmQobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHNkckxlbmd0aENvbXB1dGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHNkclRvdGFsID0gMDtcbiAgICAgICAgICAgIGxldCBzZHJMb2FkZWQgPSAwO1xuICAgICAgICAgICAgbGV0IGdhaW5NYXBMZW5ndGhDb21wdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBnYWluTWFwVG90YWwgPSAwO1xuICAgICAgICAgICAgbGV0IGdhaW5NYXBMb2FkZWQgPSAwO1xuICAgICAgICAgICAgbGV0IG1ldGFkYXRhTGVuZ3RoQ29tcHV0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgbWV0YWRhdGFUb3RhbCA9IDA7XG4gICAgICAgICAgICBsZXQgbWV0YWRhdGFMb2FkZWQgPSAwO1xuICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3NIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b3RhbCA9IHNkclRvdGFsICsgZ2Fpbk1hcFRvdGFsICsgbWV0YWRhdGFUb3RhbDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9hZGVkID0gc2RyTG9hZGVkICsgZ2Fpbk1hcExvYWRlZCArIG1ldGFkYXRhTG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhDb21wdXRhYmxlID0gc2RyTGVuZ3RoQ29tcHV0YWJsZSAmJiBnYWluTWFwTGVuZ3RoQ29tcHV0YWJsZSAmJiBtZXRhZGF0YUxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MobmV3IFByb2dyZXNzRXZlbnQoJ3Byb2dyZXNzJywgeyBsZW5ndGhDb21wdXRhYmxlLCBsb2FkZWQsIHRvdGFsIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydChzZHJVcmwpO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydChnYWluTWFwVXJsKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgY29uc3Qgc2RyTG9hZGVyID0gbmV3IHRocmVlLkZpbGVMb2FkZXIodGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlcik7XG4gICAgICAgICAgICBzZHJMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpO1xuICAgICAgICAgICAgc2RyTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgICAgICAgIHNkckxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgICAgICBzZHJMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgIHNkckxvYWRlci5sb2FkKHNkclVybCwgYXN5bmMgKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgICAgICAgICAgICAgICB0aGlzIGNvbmRpdGlvbiBleGlzdHMgb25seSBiZWNhdXNlIG9mIHRocmVlLmpzIHR5cGVzICsgc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNkciBidWZmZXInKTtcbiAgICAgICAgICAgICAgICBzZHIgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgYXdhaXQgbG9hZENoZWNrKCk7XG4gICAgICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHNkckxlbmd0aENvbXB1dGFibGUgPSBlLmxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICAgICAgc2RyTG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICAgICAgc2RyVG90YWwgPSBlLnRvdGFsO1xuICAgICAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcigpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihzZHJVcmwpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGdhaW5NYXBMb2FkZXIgPSBuZXcgdGhyZWUuRmlsZUxvYWRlcih0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyKTtcbiAgICAgICAgICAgIGdhaW5NYXBMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpO1xuICAgICAgICAgICAgZ2Fpbk1hcExvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgICAgICAgICBnYWluTWFwTG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgICAgIGdhaW5NYXBMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgIGdhaW5NYXBMb2FkZXIubG9hZChnYWluTWFwVXJsLCBhc3luYyAoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICAgICAgICAgICAgIHRoaXMgY29uZGl0aW9uIGV4aXN0cyBvbmx5IGJlY2F1c2Ugb2YgdGhyZWUuanMgdHlwZXMgKyBzdHJpY3QgbW9kZVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZ2Fpbm1hcCBidWZmZXInKTtcbiAgICAgICAgICAgICAgICBnYWluTWFwID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRDaGVjaygpO1xuICAgICAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBnYWluTWFwTGVuZ3RoQ29tcHV0YWJsZSA9IGUubGVuZ3RoQ29tcHV0YWJsZTtcbiAgICAgICAgICAgICAgICBnYWluTWFwTG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICAgICAgZ2Fpbk1hcFRvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXIoKTtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IoZ2Fpbk1hcFVybCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFMb2FkZXIgPSBuZXcgdGhyZWUuRmlsZUxvYWRlcih0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyKTtcbiAgICAgICAgICAgIC8vIG1ldGFkYXRhTG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnanNvbicpXG4gICAgICAgICAgICBtZXRhZGF0YUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgICAgICAgICBtZXRhZGF0YUxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgICAgICBtZXRhZGF0YUxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICAgICAgbWV0YWRhdGFMb2FkZXIubG9hZChtZXRhZGF0YVVybCwgYXN5bmMgKGpzb24pID0+IHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgICAgICAgICAgICAgdGhpcyBjb25kaXRpb24gZXhpc3RzIG9ubHkgYmVjYXVzZSBvZiB0aHJlZS5qcyB0eXBlcyArIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0YWRhdGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IGNoZWNrIG9uIEpTT04gZmlsZSBhbmQgcmVtb3ZlIHRoaXMgZXNsaW50IGRpc2FibGVcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRDaGVjaygpO1xuICAgICAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YUxlbmd0aENvbXB1dGFibGUgPSBlLmxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFMb2FkZWQgPSBlLmxvYWRlZDtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YVRvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXIoKTtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBxdWFkUmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIFRocmVlLmpzIExvYWRlciBmb3IgYSBKUEVHIHdpdGggZW1iZWRkZWQgZ2Fpbm1hcCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBjYXRlZ29yeSBMb2FkZXJzXG4gICAgICogQGdyb3VwIExvYWRlcnNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IHsgSERSSlBHTG9hZGVyIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnXG4gICAgICogaW1wb3J0IHtcbiAgICAgKiAgIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxuICAgICAqICAgTWVzaCxcbiAgICAgKiAgIE1lc2hCYXNpY01hdGVyaWFsLFxuICAgICAqICAgUGVyc3BlY3RpdmVDYW1lcmEsXG4gICAgICogICBQbGFuZUdlb21ldHJ5LFxuICAgICAqICAgU2NlbmUsXG4gICAgICogICBXZWJHTFJlbmRlcmVyXG4gICAgICogfSBmcm9tICd0aHJlZSdcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoKVxuICAgICAqXG4gICAgICogY29uc3QgbG9hZGVyID0gbmV3IEhEUkpQR0xvYWRlcihyZW5kZXJlcilcbiAgICAgKiAgIC5zZXRSZW5kZXJUYXJnZXRPcHRpb25zKHsgbWFwcGluZzogRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfSlcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoJ2dhaW5tYXAuanBlZycpXG4gICAgICogLy8gYHJlc3VsdGAgY2FuIGJlIHVzZWQgdG8gcG9wdWxhdGUgYSBUZXh0dXJlXG4gICAgICpcbiAgICAgKiBjb25zdCBzY2VuZSA9IG5ldyBTY2VuZSgpXG4gICAgICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKFxuICAgICAqICAgbmV3IFBsYW5lR2VvbWV0cnkoKSxcbiAgICAgKiAgIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlIH0pXG4gICAgICogKVxuICAgICAqIHNjZW5lLmFkZChtZXNoKVxuICAgICAqIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCkpXG4gICAgICpcbiAgICAgKiAvLyBTdGFydGluZyBmcm9tIHRocmVlLmpzIHIxNTlcbiAgICAgKiAvLyBgcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlYCBjYW5cbiAgICAgKiAvLyBhbHNvIGJlIHVzZWQgYXMgRXF1aXJlY3Rhbmd1bGFyIHNjZW5lIGJhY2tncm91bmRcbiAgICAgKiAvL1xuICAgICAqIC8vIGl0IHdhcyBwcmV2aW91c2x5IG5lZWRlZCB0byBjb252ZXJ0IGl0XG4gICAgICogLy8gdG8gYSBEYXRhVGV4dHVyZSB3aXRoIGByZXN1bHQudG9EYXRhVGV4dHVyZSgpYFxuICAgICAqIHNjZW5lLmJhY2tncm91bmQgPSByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVcbiAgICAgKlxuICAgICAqIC8vIHJlc3VsdCBtdXN0IGJlIG1hbnVhbGx5IGRpc3Bvc2VkXG4gICAgICogLy8gd2hlbiB5b3UgYXJlIGRvbmUgdXNpbmcgaXRcbiAgICAgKiByZXN1bHQuZGlzcG9zZSgpXG4gICAgICpcbiAgICAgKi9cbiAgICBjbGFzcyBIRFJKUEdMb2FkZXIgZXh0ZW5kcyBMb2FkZXJCYXNlV2ViR0wge1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9hZHMgYSBKUEVHIGNvbnRhaW5pbmcgZ2FpbiBtYXAgbWV0YWRhdGFcbiAgICAgICAgICogUmVuZGVycyBhIG5vcm1hbCBTRFIgaW1hZ2UgaWYgZ2Fpbm1hcCBkYXRhIGlzIG5vdCBmb3VuZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXJsIFBhdGggdG8gYSBKUEVHIGZpbGUgY29udGFpbmluZyBlbWJlZGRlZCBnYWluIG1hcCBtZXRhZGF0YVxuICAgICAgICAgKiBAcGFyYW0gb25Mb2FkIExvYWQgY29tcGxldGUgY2FsbGJhY2ssIHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0XG4gICAgICAgICAqIEBwYXJhbSBvblByb2dyZXNzIFByb2dyZXNzIGNhbGxiYWNrLCB3aWxsIHJlY2VpdmUgYSBgUHJvZ3Jlc3NFdmVudGBcbiAgICAgICAgICogQHBhcmFtIG9uRXJyb3IgRXJyb3IgY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1YWRSZW5kZXJlciA9IHRoaXMucHJlcGFyZVF1YWRSZW5kZXJlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IHRocmVlLkZpbGVMb2FkZXIodGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlcik7XG4gICAgICAgICAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpO1xuICAgICAgICAgICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgICAgICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgICAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcbiAgICAgICAgICAgIGxvYWRlci5sb2FkKHVybCwgYXN5bmMgKGpwZWcpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgICAgICAgICAgICAgdGhpcyBjb25kaXRpb24gZXhpc3RzIG9ubHkgYmVjYXVzZSBvZiB0aHJlZS5qcyB0eXBlcyArIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGpwZWcgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnVmZmVyLCByZWNlaXZlZCBbc3RyaW5nXSwgd2FzIGV4cGVjdGluZyBbQXJyYXlCdWZmZXJdJyk7XG4gICAgICAgICAgICAgICAgY29uc3QganBlZ0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGpwZWcpO1xuICAgICAgICAgICAgICAgIGxldCBzZHJKUEVHO1xuICAgICAgICAgICAgICAgIGxldCBnYWluTWFwSlBFRztcbiAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0cmFjdGlvblJlc3VsdCA9IGF3YWl0IGV4dHJhY3RHYWlubWFwRnJvbUpQRUcoanBlZ0J1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdhaW4gbWFwIGlzIHN1Y2Nlc3NmdWxseSByZWNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgICAgICAgIHNkckpQRUcgPSBleHRyYWN0aW9uUmVzdWx0LnNkcjtcbiAgICAgICAgICAgICAgICAgICAgZ2Fpbk1hcEpQRUcgPSBleHRyYWN0aW9uUmVzdWx0LmdhaW5NYXA7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gZXh0cmFjdGlvblJlc3VsdC5tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSBTRFIgdmVyc2lvbiBpZiB0aGlzIGlzIG5vdCBhIGdhaW5tYXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBYTVBNZXRhZGF0YU5vdEZvdW5kRXJyb3IgfHwgZSBpbnN0YW5jZW9mIEdhaW5NYXBOb3RGb3VuZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWx1cmUgdG8gcmVjb25zdHJ1Y3QgYW4gSERSIGltYWdlIGZyb20gJHt1cmx9OiBHYWluIG1hcCBtZXRhZGF0YSBub3QgZm91bmQgaW4gdGhlIGZpbGUsIEhEUkpQR0xvYWRlciB3aWxsIHJlbmRlciB0aGUgU0RSIGpwZWdgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhaW5NYXBNaW46IFswLCAwLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYWluTWFwTWF4OiBbMSwgMSwgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FtbWE6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1heDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRIZHI6IFswLCAwLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRTZHI6IFswLCAwLCAwXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNkckpQRUcgPSBqcGVnQnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzb2x2ZXMgIzE2XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXIocXVhZFJlbmRlcmVyLCBtZXRhZGF0YSwgc2RySlBFRy5idWZmZXIsIGdhaW5NYXBKUEVHPy5idWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkxvYWQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZChxdWFkUmVuZGVyZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICB9LCBvblByb2dyZXNzLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHF1YWRSZW5kZXJlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHMuR2Fpbk1hcERlY29kZXJNYXRlcmlhbCA9IEdhaW5NYXBEZWNvZGVyTWF0ZXJpYWw7XG4gICAgZXhwb3J0cy5HYWluTWFwTG9hZGVyID0gR2Fpbk1hcExvYWRlcjtcbiAgICBleHBvcnRzLkdhaW5NYXBOb3RGb3VuZEVycm9yID0gR2Fpbk1hcE5vdEZvdW5kRXJyb3I7XG4gICAgZXhwb3J0cy5IRFJKUEdMb2FkZXIgPSBIRFJKUEdMb2FkZXI7XG4gICAgZXhwb3J0cy5KUEVHUkxvYWRlciA9IEhEUkpQR0xvYWRlcjtcbiAgICBleHBvcnRzLkxvYWRlckJhc2VTaGFyZWQgPSBMb2FkZXJCYXNlU2hhcmVkO1xuICAgIGV4cG9ydHMuTVBGRXh0cmFjdG9yID0gTVBGRXh0cmFjdG9yO1xuICAgIGV4cG9ydHMuUXVhZFJlbmRlcmVyID0gUXVhZFJlbmRlcmVyO1xuICAgIGV4cG9ydHMuWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yID0gWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yO1xuICAgIGV4cG9ydHMuY3JlYXRlRGVjb2RlRnVuY3Rpb24gPSBjcmVhdGVEZWNvZGVGdW5jdGlvbjtcbiAgICBleHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbiAgICBleHBvcnRzLmV4dHJhY3RHYWlubWFwRnJvbUpQRUcgPSBleHRyYWN0R2Fpbm1hcEZyb21KUEVHO1xuICAgIGV4cG9ydHMuZXh0cmFjdFhNUCA9IGV4dHJhY3RYTVA7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.umd.cjs\n");

/***/ })

};
;